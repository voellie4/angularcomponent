{"ast":null,"code":"import { Subject, NEVER, ReplaySubject, isObservable, Observable, from } from 'rxjs';\nimport { mergeAll, share, materialize, tap, map, startWith, distinctUntilChanged, switchMap } from 'rxjs/operators';\nimport { coerceAllFactory } from '@rx-angular/cdk/coercing';\nfunction toRxErrorNotification(error, value) {\n  return {\n    value,\n    kind: \"error\" /* Error */,\n    hasValue: !!value || false,\n    complete: false,\n    error: error || true\n  };\n}\nfunction toRxSuspenseNotification(value) {\n  return {\n    value,\n    kind: \"suspense\" /* Suspense */,\n    hasValue: !!value || false,\n    complete: false,\n    error: false\n  };\n}\nfunction toRxCompleteNotification(value) {\n  return {\n    value,\n    kind: \"complete\" /* Complete */,\n    hasValue: !!value || false,\n    complete: true,\n    error: false\n  };\n}\n\n/**\n * @internal\n *\n * A factory function returning an object to handle the process of switching templates by Notification channel.\n * You can next a Observable of `RxNotification` multiple times and merge them into the Observable exposed under `trigger$`\n *\n */\nfunction templateTriggerHandling() {\n  const hotFlattened = coerceAllFactory(() => new Subject(), mergeAll());\n  return {\n    next(templateName) {\n      hotFlattened.next(templateName);\n    },\n    trigger$: hotFlattened.values$.pipe(share())\n  };\n}\nfunction rxMaterialize() {\n  return o$ => o$.pipe(materialize(), tap(({\n    kind,\n    error\n  }) => {\n    // As we dont want to just swallow errors we log them here\n    if (kind === 'E') {\n      console.error(error);\n    }\n  }), map(({\n    value,\n    error,\n    kind,\n    hasValue\n  }) => {\n    const rxNotificationKind = notificationKindToRxNotificationKind(kind);\n    return {\n      value,\n      hasValue,\n      error,\n      kind: rxNotificationKind,\n      complete: rxNotificationKind === \"complete\" /* Complete */\n    };\n  }));\n}\n/**\n * @internal\n *\n * @description\n * This function is here to turn RxJS notification kind values into RxNotification kind names.\n * The main reason for the naming is the RxNotification kind values map directly to the default\n * template names (`suspense`, `next`, `error` `complete`) in the directives of the template package\n */\nfunction notificationKindToRxNotificationKind(kind) {\n  switch (kind) {\n    case 'C':\n      return \"complete\" /* Complete */;\n    case 'E':\n      return \"error\" /* Error */;\n    case 'N':\n    default:\n      return \"next\" /* Next */;\n  }\n}\n\n/**\n * @description\n * Sends value and an initial `undefined` as value With a NEVER.\n * This is needed to render the suspense template and avoid completing (and render the complete template).\n * @param value\n */\nconst emitAndDontComplete = value => NEVER.pipe(startWith(value));\n/**\n * This helper is responsible for turning a stream of materialized notifications\n * (next error, complete as object in the next stream) into an enriched version with an additional suspense\n * notification type.\n *\n * If a notification enters and is of type next we store tne value of `notification.next` as last value emitted.\n * This value is important in the template to show an e.g. error and also have access to the last emitted value of\n * next.\n * The value can be very useful in error or complete messages or to display the old value overlays by a loading spinner\n * in case of the suspense state.\n *\n * If a notification of kind `next` enters and its value is undefined we turn it into a suspense notification\n * If a notification of kind `error`, `complete`, `suspense` enters we take the last value from of a next notification\n * and assign it as new value to the notification\n */\nconst handleSuspenseAndLastValueInNotifications = () => {\n  // Used to store the last value per handleSuspenseAndLastValueInNotifications call\n  let latestNextValue;\n  // returns a projection function with a lastValue cache\n  return notification => {\n    // if it is the notification is of type next we take its value\n    // otherwise we keep the existing last value\n    if (notification.kind === \"next\" /* Next */) {\n      latestNextValue = notification.value;\n    }\n    // If a next notification enters with a value of undefined we turn it into a suspense notification\n    if (notification.kind === \"next\" /* Next */ && notification.value === undefined) {\n      return toRxSuspenseNotification(undefined);\n    }\n    // If a Notification of type error, complete or suspense enters we assign the latest last value to them.\n    // This is needed to access the old value in case of error or complete.\n    // Next notifications will pass as they are.\n    if (notification.kind === \"error\" /* Error */ || notification.kind === \"complete\" /* Complete */ || notification.kind === \"suspense\" /* Suspense */) {\n      notification.value = latestNextValue;\n    }\n    return notification;\n  };\n};\n/**\n * @internal\n *\n * @description\n * This factory function returns an object that can be driven imperatively over a `next` method.\n * Internally it prepares the incoming values for rendering by turning them into \"template notifications\",\n * an extended `ObservableNotification` object used to determine the respective template for values, errors, completing\n *   or suspense states.\n *\n * Internally it handles different edge cases for initial emits. This helps to have or template creation lazy.\n * Also it maps any Observable to RxNotifications. These notifications are bound to the view later and handle the\n *   display of the default template as well as the suspense, error, complete templates.\n */\nfunction createTemplateNotifier() {\n  // A Subject driven from the outside, it can contain Observables, static values null and undefined on purpose of from unassigned properties\n  const observablesSubject = new ReplaySubject(1);\n  let emittedValueOnce = false;\n  const values$ = observablesSubject.pipe(distinctUntilChanged(),\n  // handle static values inc null assignment and new Observable or Promises\n  map(observable$ => {\n    if (isObservableInput(observable$)) {\n      return skipSuspenseIfHasValue(observable$);\n    } else if (!emittedValueOnce && observable$ === undefined) {\n      return NEVER;\n    }\n    return emitAndDontComplete(observable$);\n  }), switchMap(o => {\n    return o.pipe(tap(() => emittedValueOnce = true), distinctUntilChanged(), rxMaterialize(), map(handleSuspenseAndLastValueInNotifications()));\n  }));\n  return {\n    next(observable) {\n      observablesSubject.next(observable);\n    },\n    withInitialSuspense(withInitialSuspense) {\n      emittedValueOnce = emittedValueOnce || withInitialSuspense;\n    },\n    values$\n  };\n  /**\n   * @description\n   * returns an observable that starts with an undefined value in case the input\n   * observable$ does not emit a value immediately.\n   * This is needed in order to skip the suspense template when we already know\n   * there will be a next template rendered afterwards\n   * @param observable$\n   */\n  function skipSuspenseIfHasValue(observable$) {\n    return new Observable(subscriber => {\n      let startWithUndefined = true;\n      const inner = from(observable$).subscribe({\n        next: v => {\n          startWithUndefined = false;\n          subscriber.next(v);\n        },\n        error: e => {\n          startWithUndefined = false;\n          subscriber.error(e);\n        },\n        complete: () => subscriber.complete()\n      });\n      if (emittedValueOnce && startWithUndefined) {\n        subscriber.next(undefined);\n      }\n      return () => {\n        inner.unsubscribe();\n      };\n    });\n  }\n}\nfunction isObservableInput(input) {\n  return typeof input?.then === 'function' || isObservable(input);\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { createTemplateNotifier, rxMaterialize, templateTriggerHandling, toRxCompleteNotification, toRxErrorNotification, toRxSuspenseNotification };","map":{"version":3,"names":["Subject","NEVER","ReplaySubject","isObservable","Observable","from","mergeAll","share","materialize","tap","map","startWith","distinctUntilChanged","switchMap","coerceAllFactory","toRxErrorNotification","error","value","kind","hasValue","complete","toRxSuspenseNotification","toRxCompleteNotification","templateTriggerHandling","hotFlattened","next","templateName","trigger$","values$","pipe","rxMaterialize","o$","console","rxNotificationKind","notificationKindToRxNotificationKind","emitAndDontComplete","handleSuspenseAndLastValueInNotifications","latestNextValue","notification","undefined","createTemplateNotifier","observablesSubject","emittedValueOnce","observable$","isObservableInput","skipSuspenseIfHasValue","o","observable","withInitialSuspense","subscriber","startWithUndefined","inner","subscribe","v","e","unsubscribe","input","then"],"sources":["C:/Development/AngularComponent/ClientApp/node_modules/@rx-angular/cdk/fesm2020/cdk-notifications.mjs"],"sourcesContent":["import { Subject, NEVER, ReplaySubject, isObservable, Observable, from } from 'rxjs';\nimport { mergeAll, share, materialize, tap, map, startWith, distinctUntilChanged, switchMap } from 'rxjs/operators';\nimport { coerceAllFactory } from '@rx-angular/cdk/coercing';\n\nfunction toRxErrorNotification(error, value) {\n    return {\n        value,\n        kind: \"error\" /* Error */,\n        hasValue: !!value || false,\n        complete: false,\n        error: error || true,\n    };\n}\nfunction toRxSuspenseNotification(value) {\n    return {\n        value,\n        kind: \"suspense\" /* Suspense */,\n        hasValue: !!value || false,\n        complete: false,\n        error: false,\n    };\n}\nfunction toRxCompleteNotification(value) {\n    return {\n        value,\n        kind: \"complete\" /* Complete */,\n        hasValue: !!value || false,\n        complete: true,\n        error: false,\n    };\n}\n\n/**\n * @internal\n *\n * A factory function returning an object to handle the process of switching templates by Notification channel.\n * You can next a Observable of `RxNotification` multiple times and merge them into the Observable exposed under `trigger$`\n *\n */\nfunction templateTriggerHandling() {\n    const hotFlattened = coerceAllFactory(() => new Subject(), mergeAll());\n    return {\n        next(templateName) {\n            hotFlattened.next(templateName);\n        },\n        trigger$: hotFlattened.values$.pipe(share()),\n    };\n}\n\nfunction rxMaterialize() {\n    return (o$) => o$.pipe(materialize(), tap(({ kind, error }) => {\n        // As we dont want to just swallow errors we log them here\n        if (kind === 'E') {\n            console.error(error);\n        }\n    }), map(({ value, error, kind, hasValue }) => {\n        const rxNotificationKind = notificationKindToRxNotificationKind(kind);\n        return {\n            value,\n            hasValue,\n            error,\n            kind: rxNotificationKind,\n            complete: rxNotificationKind === \"complete\" /* Complete */,\n        };\n    }));\n}\n/**\n * @internal\n *\n * @description\n * This function is here to turn RxJS notification kind values into RxNotification kind names.\n * The main reason for the naming is the RxNotification kind values map directly to the default\n * template names (`suspense`, `next`, `error` `complete`) in the directives of the template package\n */\nfunction notificationKindToRxNotificationKind(kind) {\n    switch (kind) {\n        case 'C':\n            return \"complete\" /* Complete */;\n        case 'E':\n            return \"error\" /* Error */;\n        case 'N':\n        default:\n            return \"next\" /* Next */;\n    }\n}\n\n/**\n * @description\n * Sends value and an initial `undefined` as value With a NEVER.\n * This is needed to render the suspense template and avoid completing (and render the complete template).\n * @param value\n */\nconst emitAndDontComplete = (value) => NEVER.pipe(startWith(value));\n/**\n * This helper is responsible for turning a stream of materialized notifications\n * (next error, complete as object in the next stream) into an enriched version with an additional suspense\n * notification type.\n *\n * If a notification enters and is of type next we store tne value of `notification.next` as last value emitted.\n * This value is important in the template to show an e.g. error and also have access to the last emitted value of\n * next.\n * The value can be very useful in error or complete messages or to display the old value overlays by a loading spinner\n * in case of the suspense state.\n *\n * If a notification of kind `next` enters and its value is undefined we turn it into a suspense notification\n * If a notification of kind `error`, `complete`, `suspense` enters we take the last value from of a next notification\n * and assign it as new value to the notification\n */\nconst handleSuspenseAndLastValueInNotifications = () => {\n    // Used to store the last value per handleSuspenseAndLastValueInNotifications call\n    let latestNextValue;\n    // returns a projection function with a lastValue cache\n    return (notification) => {\n        // if it is the notification is of type next we take its value\n        // otherwise we keep the existing last value\n        if (notification.kind === \"next\" /* Next */) {\n            latestNextValue = notification.value;\n        }\n        // If a next notification enters with a value of undefined we turn it into a suspense notification\n        if (notification.kind === \"next\" /* Next */ &&\n            notification.value === undefined) {\n            return toRxSuspenseNotification(undefined);\n        }\n        // If a Notification of type error, complete or suspense enters we assign the latest last value to them.\n        // This is needed to access the old value in case of error or complete.\n        // Next notifications will pass as they are.\n        if (notification.kind === \"error\" /* Error */ ||\n            notification.kind === \"complete\" /* Complete */ ||\n            notification.kind === \"suspense\" /* Suspense */) {\n            notification.value = latestNextValue;\n        }\n        return notification;\n    };\n};\n/**\n * @internal\n *\n * @description\n * This factory function returns an object that can be driven imperatively over a `next` method.\n * Internally it prepares the incoming values for rendering by turning them into \"template notifications\",\n * an extended `ObservableNotification` object used to determine the respective template for values, errors, completing\n *   or suspense states.\n *\n * Internally it handles different edge cases for initial emits. This helps to have or template creation lazy.\n * Also it maps any Observable to RxNotifications. These notifications are bound to the view later and handle the\n *   display of the default template as well as the suspense, error, complete templates.\n */\nfunction createTemplateNotifier() {\n    // A Subject driven from the outside, it can contain Observables, static values null and undefined on purpose of from unassigned properties\n    const observablesSubject = new ReplaySubject(1);\n    let emittedValueOnce = false;\n    const values$ = observablesSubject.pipe(distinctUntilChanged(), \n    // handle static values inc null assignment and new Observable or Promises\n    map((observable$) => {\n        if (isObservableInput(observable$)) {\n            return skipSuspenseIfHasValue(observable$);\n        }\n        else if (!emittedValueOnce && observable$ === undefined) {\n            return NEVER;\n        }\n        return emitAndDontComplete(observable$);\n    }), switchMap((o) => {\n        return o.pipe(tap(() => (emittedValueOnce = true)), distinctUntilChanged(), rxMaterialize(), map(handleSuspenseAndLastValueInNotifications()));\n    }));\n    return {\n        next(observable) {\n            observablesSubject.next(observable);\n        },\n        withInitialSuspense(withInitialSuspense) {\n            emittedValueOnce = emittedValueOnce || withInitialSuspense;\n        },\n        values$,\n    };\n    /**\n     * @description\n     * returns an observable that starts with an undefined value in case the input\n     * observable$ does not emit a value immediately.\n     * This is needed in order to skip the suspense template when we already know\n     * there will be a next template rendered afterwards\n     * @param observable$\n     */\n    function skipSuspenseIfHasValue(observable$) {\n        return new Observable((subscriber) => {\n            let startWithUndefined = true;\n            const inner = from(observable$).subscribe({\n                next: (v) => {\n                    startWithUndefined = false;\n                    subscriber.next(v);\n                },\n                error: (e) => {\n                    startWithUndefined = false;\n                    subscriber.error(e);\n                },\n                complete: () => subscriber.complete(),\n            });\n            if (emittedValueOnce && startWithUndefined) {\n                subscriber.next(undefined);\n            }\n            return () => {\n                inner.unsubscribe();\n            };\n        });\n    }\n}\nfunction isObservableInput(input) {\n    return (typeof input?.then === 'function' || isObservable(input));\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { createTemplateNotifier, rxMaterialize, templateTriggerHandling, toRxCompleteNotification, toRxErrorNotification, toRxSuspenseNotification };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}