{"ast":null,"code":"import { isObservable, of, Subject } from 'rxjs';\nimport { map, switchAll, distinctUntilChanged } from 'rxjs/operators';\n\n/**\n * This Observable factory creates an Observable out of a static value or ObservableInput.\n *\n * @param o - the value to coerce\n */\nfunction coerceObservable(o) {\n  return isObservable(o) ? o : of(o);\n}\n\n/**\n * This operator maps an Observable out of a static value or ObservableInput.\n *\n */\nfunction coerceObservableWith() {\n  return o$ => map(coerceObservable)(o$);\n}\n\n/**\n * This Observable factory creates an Observable out of a static value or ObservableInput.\n * It forwards only distinct values from distinct incoming Observables or values.\n * This comes in handy in any environment where you handle processing of incoming dynamic values and their state.\n *\n * Optionally you can pass a flatten strategy to get find grained control of the flattening process. E.g. mergeAll, switchAll\n *\n * @param o$ - The Observable to coerce and map to a Observable with distinct values\n * @param flattenOperator - determines the flattening strategy e.g. mergeAll, concatAll, exhaust, switchAll. default is switchAll\n */\nfunction coerceDistinctObservable(o$, flattenOperator) {\n  flattenOperator = flattenOperator || switchAll();\n  return coerceObservable(o$).pipe(distinctUntilChanged(), flattenOperator, distinctUntilChanged());\n}\n\n/**\n * This operator takes an Observable of values ot Observables aof values and\n * It forwards only distinct values from distinct incoming Observables or values.\n * This comes in handy in any environment where you handle processing of incoming dynamic values and their state.\n *\n * Optionally you can pass a flatten strategy to get find grained control of the flattening process. E.g. mergeAll, switchAll\n *\n * @param flattenOperator - determines the flattening strategy e.g. mergeAll, concatAll, exhaust, switchAll. default is switchAll\n *\n */\nfunction coerceDistinctWith(flattenOperator) {\n  flattenOperator = flattenOperator || switchAll();\n  return o$ => o$.pipe(coerceObservableWith(), distinctUntilChanged(), flattenOperator, distinctUntilChanged());\n}\n\n/**\n * @internal\n *\n * A factory function returning an object to handle the process of merging Observable next notifications into one\n *   Observable. This API takes away the clumsy handling of static values and Observable, reduces the number of\n *   emissions by:\n * - only merging distinct Observables\n * - only emit distingt values of the merged result\n *\n * You can next a Observable of `U` multiple times and merge them into the Observable exposed under one optimized\n *   `values$`\n *\n */\nfunction coerceAllFactory(subjectFactory, flattenOperator) {\n  const observablesSubject = subjectFactory ? subjectFactory() : new Subject();\n  flattenOperator = flattenOperator || switchAll();\n  const values$ = observablesSubject.pipe(coerceDistinctWith(flattenOperator));\n  return {\n    next(observable) {\n      observablesSubject.next(observable);\n    },\n    values$\n  };\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { coerceAllFactory, coerceDistinctObservable, coerceDistinctWith, coerceObservable, coerceObservableWith };","map":{"version":3,"names":["isObservable","of","Subject","map","switchAll","distinctUntilChanged","coerceObservable","o","coerceObservableWith","o$","coerceDistinctObservable","flattenOperator","pipe","coerceDistinctWith","coerceAllFactory","subjectFactory","observablesSubject","values$","next","observable"],"sources":["C:/Development/AngularComponent/ClientApp/node_modules/@rx-angular/cdk/fesm2020/cdk-coercing.mjs"],"sourcesContent":["import { isObservable, of, Subject } from 'rxjs';\nimport { map, switchAll, distinctUntilChanged } from 'rxjs/operators';\n\n/**\n * This Observable factory creates an Observable out of a static value or ObservableInput.\n *\n * @param o - the value to coerce\n */\nfunction coerceObservable(o) {\n    return isObservable(o) ? o : of(o);\n}\n\n/**\n * This operator maps an Observable out of a static value or ObservableInput.\n *\n */\nfunction coerceObservableWith() {\n    return (o$) => map(coerceObservable)(o$);\n}\n\n/**\n * This Observable factory creates an Observable out of a static value or ObservableInput.\n * It forwards only distinct values from distinct incoming Observables or values.\n * This comes in handy in any environment where you handle processing of incoming dynamic values and their state.\n *\n * Optionally you can pass a flatten strategy to get find grained control of the flattening process. E.g. mergeAll, switchAll\n *\n * @param o$ - The Observable to coerce and map to a Observable with distinct values\n * @param flattenOperator - determines the flattening strategy e.g. mergeAll, concatAll, exhaust, switchAll. default is switchAll\n */\nfunction coerceDistinctObservable(o$, flattenOperator) {\n    flattenOperator = flattenOperator || switchAll();\n    return coerceObservable(o$).pipe(distinctUntilChanged(), flattenOperator, distinctUntilChanged());\n}\n\n/**\n * This operator takes an Observable of values ot Observables aof values and\n * It forwards only distinct values from distinct incoming Observables or values.\n * This comes in handy in any environment where you handle processing of incoming dynamic values and their state.\n *\n * Optionally you can pass a flatten strategy to get find grained control of the flattening process. E.g. mergeAll, switchAll\n *\n * @param flattenOperator - determines the flattening strategy e.g. mergeAll, concatAll, exhaust, switchAll. default is switchAll\n *\n */\nfunction coerceDistinctWith(flattenOperator) {\n    flattenOperator = flattenOperator || switchAll();\n    return (o$) => o$.pipe(coerceObservableWith(), distinctUntilChanged(), flattenOperator, distinctUntilChanged());\n}\n\n/**\n * @internal\n *\n * A factory function returning an object to handle the process of merging Observable next notifications into one\n *   Observable. This API takes away the clumsy handling of static values and Observable, reduces the number of\n *   emissions by:\n * - only merging distinct Observables\n * - only emit distingt values of the merged result\n *\n * You can next a Observable of `U` multiple times and merge them into the Observable exposed under one optimized\n *   `values$`\n *\n */\nfunction coerceAllFactory(subjectFactory, flattenOperator) {\n    const observablesSubject = subjectFactory ? subjectFactory() : new Subject();\n    flattenOperator = flattenOperator || switchAll();\n    const values$ = observablesSubject.pipe(coerceDistinctWith(flattenOperator));\n    return {\n        next(observable) {\n            observablesSubject.next(observable);\n        },\n        values$,\n    };\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { coerceAllFactory, coerceDistinctObservable, coerceDistinctWith, coerceObservable, coerceObservableWith };\n"],"mappings":"AAAA,SAASA,YAAY,EAAEC,EAAE,EAAEC,OAAO,QAAQ,MAAM;AAChD,SAASC,GAAG,EAAEC,SAAS,EAAEC,oBAAoB,QAAQ,gBAAgB;;AAErE;AACA;AACA;AACA;AACA;AACA,SAASC,gBAAgB,CAACC,CAAC,EAAE;EACzB,OAAOP,YAAY,CAACO,CAAC,CAAC,GAAGA,CAAC,GAAGN,EAAE,CAACM,CAAC,CAAC;AACtC;;AAEA;AACA;AACA;AACA;AACA,SAASC,oBAAoB,GAAG;EAC5B,OAAQC,EAAE,IAAKN,GAAG,CAACG,gBAAgB,CAAC,CAACG,EAAE,CAAC;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,wBAAwB,CAACD,EAAE,EAAEE,eAAe,EAAE;EACnDA,eAAe,GAAGA,eAAe,IAAIP,SAAS,EAAE;EAChD,OAAOE,gBAAgB,CAACG,EAAE,CAAC,CAACG,IAAI,CAACP,oBAAoB,EAAE,EAAEM,eAAe,EAAEN,oBAAoB,EAAE,CAAC;AACrG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASQ,kBAAkB,CAACF,eAAe,EAAE;EACzCA,eAAe,GAAGA,eAAe,IAAIP,SAAS,EAAE;EAChD,OAAQK,EAAE,IAAKA,EAAE,CAACG,IAAI,CAACJ,oBAAoB,EAAE,EAAEH,oBAAoB,EAAE,EAAEM,eAAe,EAAEN,oBAAoB,EAAE,CAAC;AACnH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASS,gBAAgB,CAACC,cAAc,EAAEJ,eAAe,EAAE;EACvD,MAAMK,kBAAkB,GAAGD,cAAc,GAAGA,cAAc,EAAE,GAAG,IAAIb,OAAO,EAAE;EAC5ES,eAAe,GAAGA,eAAe,IAAIP,SAAS,EAAE;EAChD,MAAMa,OAAO,GAAGD,kBAAkB,CAACJ,IAAI,CAACC,kBAAkB,CAACF,eAAe,CAAC,CAAC;EAC5E,OAAO;IACHO,IAAI,CAACC,UAAU,EAAE;MACbH,kBAAkB,CAACE,IAAI,CAACC,UAAU,CAAC;IACvC,CAAC;IACDF;EACJ,CAAC;AACL;;AAEA;AACA;AACA;;AAEA,SAASH,gBAAgB,EAAEJ,wBAAwB,EAAEG,kBAAkB,EAAEP,gBAAgB,EAAEE,oBAAoB"},"metadata":{},"sourceType":"module","externalDependencies":[]}