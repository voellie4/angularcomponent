{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Directive, Input, Output, NgModule } from '@angular/core';\nimport { coerceAllFactory } from '@rx-angular/cdk/coercing';\nimport { createTemplateNotifier } from '@rx-angular/cdk/notifications';\nimport * as i1 from '@rx-angular/cdk/render-strategies';\nimport { RxBaseTemplateNames, createTemplateManager } from '@rx-angular/cdk/template';\nimport { ReplaySubject, Subscription, Subject, defer, merge, NEVER } from 'rxjs';\nimport { map, filter } from 'rxjs/operators';\n\n/** @internal */\nconst RxLetTemplateNames = {\n  ...RxBaseTemplateNames,\n  next: 'nextTpl'\n};\n/**\n * @Directive LetDirective\n *\n * @description\n * In Angular there is one way to handle asynchronous values or streams in the template, the `async` pipe.\n * Even though the async pipe evaluates such values in the template, it is insufficient in many ways.\n * To name a few:\n * * it will only update the template when `NgZone` is also aware of the value change\n * * it leads to over rendering because it can only run global change detection\n * * it leads to too many subscriptions in the template\n * * it is cumbersome to work with values in the template\n *\n * read more about the LetDirective in the [official docs](https://www.rx-angular.io/docs/template/api/let-directive)\n *\n * **Conclusion - Structural directives**\n *\n * In contrast to global change detection, structural directives allow fine-grained control of change detection on a per directive basis.\n * The `LetDirective` comes with its own way to handle change detection in templates in a very efficient way.\n * However, the change detection behavior is configurable on a per directive or global basis.\n * This makes it possible to implement your own strategies, and also provides a migration path from large existing apps running with Angulars default change detection.\n *\n * This package helps to reduce code used to create composable action streams.\n * It mostly is used in combination with state management libs to handle user interaction and backend communication.\n *\n * ```html\n * <ng-container *rxLet=\"observableNumber$; let n\">\n *  ...\n * </ng-container>\n * ```\n *\n *\n * @docsCategory LetDirective\n * @docsPage LetDirective\n * @publicApi\n */\nclass LetDirective {\n  constructor(strategyProvider, cdRef, ngZone, nextTemplateRef, viewContainerRef, errorHandler) {\n    this.strategyProvider = strategyProvider;\n    this.cdRef = cdRef;\n    this.ngZone = ngZone;\n    this.nextTemplateRef = nextTemplateRef;\n    this.viewContainerRef = viewContainerRef;\n    this.errorHandler = errorHandler;\n    /**\n     * @description\n     *\n     * When local rendering strategies are used, we need to treat view and content queries in a\n     * special way.\n     * To make `*rxLet` in such situations, a certain mechanism is implemented to\n     * execute change detection on the parent (`parent`).\n     *\n     * This is required if your components state is dependent on its view or content children:\n     *\n     * - `@ViewChild`\n     * - `@ViewChildren`\n     * - `@ContentChild`\n     * - `@ContentChildren`\n     *\n     * Read more about this in the\n     * [official\n     * docs](https://www.rx-angular.io/docs/template/api/let-directive#local-strategies-and-view-content-queries-parent).\n     *\n     * @example\n     * \\@Component({\n     *   selector: 'app-root',\n     *   template: `\n     *    <app-list-component>\n     *      <app-list-item\n     *        *rxLet=\"\n     *          item$;\n     *          let item;\n     *          parent: true;\n     *        \"\n     *      >\n     *        <div>{{ item.name }}</div>\n     *      </app-list-item>\n     *    </app-list-component>\n     *   `\n     * })\n     * export class AppComponent {\n     *   item$ = itemService.getItem();\n     * }\n     *\n     * @param boolean\n     */\n    this.renderParent = this.strategyProvider.config.parent;\n    /**\n     * @description\n     * A flag to control whether *rxLet templates are created within `NgZone` or not.\n     * The default value is `true, `*rxLet` will create it's `EmbeddedViews` inside `NgZone`.\n     *\n     * Event listeners normally trigger zone. Especially high frequently events cause performance issues.\n     *\n     * Read more about this in the\n     * [official docs](https://www.rx-angular.io/docs/template/api/let-directive#working-with-event-listeners-patchzone).\n     *\n     * @example\n     * \\@Component({\n     *   selector: 'app-root',\n     *   template: `\n     *    <app-list-component>\n     *      <app-list-item\n     *        *rxLet=\"\n     *          item$;\n     *          let item;\n     *          patchZone: false;\n     *        \"\n     *      >\n     *        <div>{{ item.name }}</div>\n     *      </app-list-item>\n     *    </app-list-component>\n     *   `\n     * })\n     * export class AppComponent {\n     *   item$ = itemService.getItem();\n     * }\n     */\n    this.patchZone = this.strategyProvider.config.patchZone;\n    /** @internal */\n    this.observablesHandler = createTemplateNotifier();\n    /** @internal */\n    this.strategyHandler = coerceAllFactory(() => new ReplaySubject(1));\n    /** @internal */\n    this.triggerHandler = new ReplaySubject(1);\n    /** @internal */\n    this.subscription = new Subscription();\n    /** @internal */\n    this.rendered$ = new Subject();\n    /** @internal */\n    this.templateNotification$ = new Subject();\n    /** @internal */\n    this.values$ = this.observablesHandler.values$;\n    this.rendered = defer(() => this.rendered$);\n  }\n  /**\n   * @description\n   *\n   * You can change the used `RenderStrategy` by using the `strategy` input of the `*rxLet`. It accepts\n   * an `Observable<RxStrategyNames>` or [`RxStrategyNames`](https://github.com/rx-angular/rx-angular/blob/b0630f69017cc1871d093e976006066d5f2005b9/libs/cdk/render-strategies/src/lib/model.ts#L52).\n   *\n   * The default value for strategy is\n   * [`normal`](https://www.rx-angular.io/docs/template/cdk/render-strategies/strategies/concurrent-strategies).\n   *\n   * Read more about this in the\n   * [official docs](https://www.rx-angular.io/docs/template/api/let-directive#use-render-strategies-strategy).\n   *\n   * @example\n   *\n   * \\@Component({\n   *   selector: 'app-root',\n   *   template: `\n   *     <ng-container *rxLet=\"hero$; let hero; strategy: strategy\">\n   *       <app-hero [hero]=\"hero\"></app-hero>\n   *     </ng-container>\n   *\n   *     <ng-container *rxLet=\"hero$; let hero; strategy: strategy$\">\n   *       <app-hero [hero]=\"hero\"></app-hero>\n   *     </ng-container>\n   *   `\n   * })\n   * export class AppComponent {\n   *   strategy = 'low';\n   *   strategy$ = of('immediate');\n   * }\n   *\n   * @param { string | Observable<string> | undefined } strategyName\n   * @see {@link RxStrategyNames}\n   */\n  set strategy(strategyName) {\n    this.strategyHandler.next(strategyName);\n  }\n  /**\n   * @description\n   * A `Subject` which emits whenever *rxFor finished rendering a set changes to the view.\n   * This enables developers to perform actions when a list has finished rendering.\n   * The `renderCallback` is useful in situations where you rely on specific DOM properties like the `height` a\n   * table after all items got rendered.\n   * It is also possible to use the renderCallback in order to determine if a view should be visible or not. This\n   * way developers can hide a list as long as it has not finished rendering.\n   *\n   * The result of the `renderCallback` will contain the currently rendered set of items in the iterable.\n   *\n   * @example\n   * \\Component({\n   *   selector: 'app-root',\n   *   template: `\n   *   <app-list-component>\n   *     <app-list-item\n   *       *rxFor=\"\n   *         let item of items$;\n   *         trackBy: trackItem;\n   *         renderCallback: itemsRendered;\n   *       \">\n   *       <div>{{ item.name }}</div>\n   *     </app-list-item>\n   *   </app-list-component>\n   * `\n   * })\n   * export class AppComponent {\n   *   items$: Observable<Item[]> = itemService.getItems();\n   *   trackItem = (idx, item) => item.id;\n   *   // this emits whenever rxFor finished rendering changes\n   *   itemsRendered = new Subject<Item[]>();\n   *\n   *   constructor(elementRef: ElementRef<HTMLElement>) {\n   *     itemsRendered.subscribe(() => {\n   *       // items are rendered, we can now scroll\n   *       elementRef.scrollTo({bottom: 0});\n   *     })\n   *   }\n   * }\n   *\n   * @param {Subject<U>} renderCallback\n   */\n  set renderCallback(callback) {\n    this._renderObserver = callback;\n  }\n  /** @internal */\n  static ngTemplateContextGuard(dir, ctx) {\n    return true;\n  }\n  /** @internal */\n  ngOnInit() {\n    this.subscription.add(this.templateManager.render(merge(this.values$, this.templateNotification$)).subscribe(n => {\n      this.rendered$.next(n);\n      this._renderObserver?.next(n);\n    }));\n    this.subscription.add(merge(this.contextTrigger || NEVER, this.nextTrigger?.pipe(map(() => \"next\" /* Next */)) || NEVER, this.suspenseTrigger?.pipe(map(() => \"suspense\" /* Suspense */)) || NEVER, this.completeTrigger?.pipe(map(() => \"complete\" /* Complete */)) || NEVER, this.errorTrigger?.pipe(map(() => \"error\" /* Error */)) || NEVER).pipe(filter(v => !!v)).subscribe(t => this.triggerHandler.next(t)));\n  }\n  /** @internal */\n  ngOnChanges(changes) {\n    if (!this.templateManager) {\n      this._createTemplateManager();\n    }\n    if (changes.complete) {\n      this.templateManager.addTemplateRef(RxLetTemplateNames.complete, this.complete);\n    }\n    if (changes.suspense) {\n      this.templateManager.addTemplateRef(RxLetTemplateNames.suspense, this.suspense);\n      this.observablesHandler.withInitialSuspense(!!this.suspense);\n    }\n    if (changes.error) {\n      this.templateManager.addTemplateRef(RxLetTemplateNames.error, this.error);\n    }\n    if (changes.rxLet) {\n      this.observablesHandler.next(this.rxLet);\n    }\n  }\n  /** @internal */\n  ngOnDestroy() {\n    this.subscription.unsubscribe();\n  }\n  /** @internal */\n  _createTemplateManager() {\n    this.templateManager = createTemplateManager({\n      templateSettings: {\n        viewContainerRef: this.viewContainerRef,\n        customContext: rxLet => ({\n          rxLet\n        })\n      },\n      renderSettings: {\n        cdRef: this.cdRef,\n        parent: !!this.renderParent,\n        patchZone: this.patchZone ? this.ngZone : false,\n        defaultStrategyName: this.strategyProvider.primaryStrategy,\n        strategies: this.strategyProvider.strategies,\n        errorHandler: this.errorHandler\n      },\n      notificationToTemplateName: {\n        [\"suspense\" /* Suspense */]: () => this.suspense ? RxLetTemplateNames.suspense : RxLetTemplateNames.next,\n        [\"next\" /* Next */]: () => RxLetTemplateNames.next,\n        [\"error\" /* Error */]: () => this.error ? RxLetTemplateNames.error : RxLetTemplateNames.next,\n        [\"complete\" /* Complete */]: () => this.complete ? RxLetTemplateNames.complete : RxLetTemplateNames.next\n      },\n      templateTrigger$: this.triggerHandler\n    });\n    this.templateManager.addTemplateRef(RxLetTemplateNames.next, this.nextTemplateRef);\n    this.templateManager.nextStrategy(this.strategyHandler.values$);\n  }\n}\n/** @nocollapse */\nLetDirective.ɵfac = function LetDirective_Factory(t) {\n  return new (t || LetDirective)(i0.ɵɵdirectiveInject(i1.RxStrategyProvider), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ErrorHandler));\n};\n/** @nocollapse */\nLetDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: LetDirective,\n  selectors: [[\"\", \"rxLet\", \"\"]],\n  inputs: {\n    rxLet: \"rxLet\",\n    strategy: [\"rxLetStrategy\", \"strategy\"],\n    complete: [\"rxLetComplete\", \"complete\"],\n    error: [\"rxLetError\", \"error\"],\n    suspense: [\"rxLetSuspense\", \"suspense\"],\n    contextTrigger: [\"rxLetContextTrigger\", \"contextTrigger\"],\n    completeTrigger: [\"rxLetCompleteTrigger\", \"completeTrigger\"],\n    errorTrigger: [\"rxLetErrorTrigger\", \"errorTrigger\"],\n    suspenseTrigger: [\"rxLetSuspenseTrigger\", \"suspenseTrigger\"],\n    nextTrigger: [\"rxLetNextTrigger\", \"nextTrigger\"],\n    renderCallback: [\"rxLetRenderCallback\", \"renderCallback\"],\n    renderParent: [\"rxLetParent\", \"renderParent\"],\n    patchZone: [\"rxLetPatchZone\", \"patchZone\"]\n  },\n  outputs: {\n    rendered: \"rendered\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LetDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[rxLet]'\n    }]\n  }], function () {\n    return [{\n      type: i1.RxStrategyProvider\n    }, {\n      type: i0.ChangeDetectorRef\n    }, {\n      type: i0.NgZone\n    }, {\n      type: i0.TemplateRef\n    }, {\n      type: i0.ViewContainerRef\n    }, {\n      type: i0.ErrorHandler\n    }];\n  }, {\n    rxLet: [{\n      type: Input\n    }],\n    strategy: [{\n      type: Input,\n      args: ['rxLetStrategy']\n    }],\n    complete: [{\n      type: Input,\n      args: ['rxLetComplete']\n    }],\n    error: [{\n      type: Input,\n      args: ['rxLetError']\n    }],\n    suspense: [{\n      type: Input,\n      args: ['rxLetSuspense']\n    }],\n    contextTrigger: [{\n      type: Input,\n      args: ['rxLetContextTrigger']\n    }],\n    completeTrigger: [{\n      type: Input,\n      args: ['rxLetCompleteTrigger']\n    }],\n    errorTrigger: [{\n      type: Input,\n      args: ['rxLetErrorTrigger']\n    }],\n    suspenseTrigger: [{\n      type: Input,\n      args: ['rxLetSuspenseTrigger']\n    }],\n    nextTrigger: [{\n      type: Input,\n      args: ['rxLetNextTrigger']\n    }],\n    renderCallback: [{\n      type: Input,\n      args: ['rxLetRenderCallback']\n    }],\n    renderParent: [{\n      type: Input,\n      args: ['rxLetParent']\n    }],\n    patchZone: [{\n      type: Input,\n      args: ['rxLetPatchZone']\n    }],\n    rendered: [{\n      type: Output\n    }]\n  });\n})();\nclass LetModule {}\n/** @nocollapse */\nLetModule.ɵfac = function LetModule_Factory(t) {\n  return new (t || LetModule)();\n};\n/** @nocollapse */\nLetModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: LetModule\n});\n/** @nocollapse */\nLetModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LetModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [LetDirective],\n      exports: [LetDirective]\n    }]\n  }], null, null);\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { LetDirective, LetModule };","map":{"version":3,"names":["i0","Directive","Input","Output","NgModule","coerceAllFactory","createTemplateNotifier","i1","RxBaseTemplateNames","createTemplateManager","ReplaySubject","Subscription","Subject","defer","merge","NEVER","map","filter","RxLetTemplateNames","next","LetDirective","constructor","strategyProvider","cdRef","ngZone","nextTemplateRef","viewContainerRef","errorHandler","renderParent","config","parent","patchZone","observablesHandler","strategyHandler","triggerHandler","subscription","rendered$","templateNotification$","values$","rendered","strategy","strategyName","renderCallback","callback","_renderObserver","ngTemplateContextGuard","dir","ctx","ngOnInit","add","templateManager","render","subscribe","n","contextTrigger","nextTrigger","pipe","suspenseTrigger","completeTrigger","errorTrigger","v","t","ngOnChanges","changes","_createTemplateManager","complete","addTemplateRef","suspense","withInitialSuspense","error","rxLet","ngOnDestroy","unsubscribe","templateSettings","customContext","renderSettings","defaultStrategyName","primaryStrategy","strategies","notificationToTemplateName","templateTrigger$","nextStrategy","ɵfac","RxStrategyProvider","ChangeDetectorRef","NgZone","TemplateRef","ViewContainerRef","ErrorHandler","ɵdir","type","args","selector","LetModule","ɵmod","ɵinj","declarations","exports"],"sources":["C:/Development/AngularComponent/ClientApp/node_modules/@rx-angular/template/fesm2020/template-let.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Directive, Input, Output, NgModule } from '@angular/core';\nimport { coerceAllFactory } from '@rx-angular/cdk/coercing';\nimport { createTemplateNotifier } from '@rx-angular/cdk/notifications';\nimport * as i1 from '@rx-angular/cdk/render-strategies';\nimport { RxBaseTemplateNames, createTemplateManager } from '@rx-angular/cdk/template';\nimport { ReplaySubject, Subscription, Subject, defer, merge, NEVER } from 'rxjs';\nimport { map, filter } from 'rxjs/operators';\n\n/** @internal */\nconst RxLetTemplateNames = {\n    ...RxBaseTemplateNames,\n    next: 'nextTpl',\n};\n/**\n * @Directive LetDirective\n *\n * @description\n * In Angular there is one way to handle asynchronous values or streams in the template, the `async` pipe.\n * Even though the async pipe evaluates such values in the template, it is insufficient in many ways.\n * To name a few:\n * * it will only update the template when `NgZone` is also aware of the value change\n * * it leads to over rendering because it can only run global change detection\n * * it leads to too many subscriptions in the template\n * * it is cumbersome to work with values in the template\n *\n * read more about the LetDirective in the [official docs](https://www.rx-angular.io/docs/template/api/let-directive)\n *\n * **Conclusion - Structural directives**\n *\n * In contrast to global change detection, structural directives allow fine-grained control of change detection on a per directive basis.\n * The `LetDirective` comes with its own way to handle change detection in templates in a very efficient way.\n * However, the change detection behavior is configurable on a per directive or global basis.\n * This makes it possible to implement your own strategies, and also provides a migration path from large existing apps running with Angulars default change detection.\n *\n * This package helps to reduce code used to create composable action streams.\n * It mostly is used in combination with state management libs to handle user interaction and backend communication.\n *\n * ```html\n * <ng-container *rxLet=\"observableNumber$; let n\">\n *  ...\n * </ng-container>\n * ```\n *\n *\n * @docsCategory LetDirective\n * @docsPage LetDirective\n * @publicApi\n */\nclass LetDirective {\n    constructor(strategyProvider, cdRef, ngZone, nextTemplateRef, viewContainerRef, errorHandler) {\n        this.strategyProvider = strategyProvider;\n        this.cdRef = cdRef;\n        this.ngZone = ngZone;\n        this.nextTemplateRef = nextTemplateRef;\n        this.viewContainerRef = viewContainerRef;\n        this.errorHandler = errorHandler;\n        /**\n         * @description\n         *\n         * When local rendering strategies are used, we need to treat view and content queries in a\n         * special way.\n         * To make `*rxLet` in such situations, a certain mechanism is implemented to\n         * execute change detection on the parent (`parent`).\n         *\n         * This is required if your components state is dependent on its view or content children:\n         *\n         * - `@ViewChild`\n         * - `@ViewChildren`\n         * - `@ContentChild`\n         * - `@ContentChildren`\n         *\n         * Read more about this in the\n         * [official\n         * docs](https://www.rx-angular.io/docs/template/api/let-directive#local-strategies-and-view-content-queries-parent).\n         *\n         * @example\n         * \\@Component({\n         *   selector: 'app-root',\n         *   template: `\n         *    <app-list-component>\n         *      <app-list-item\n         *        *rxLet=\"\n         *          item$;\n         *          let item;\n         *          parent: true;\n         *        \"\n         *      >\n         *        <div>{{ item.name }}</div>\n         *      </app-list-item>\n         *    </app-list-component>\n         *   `\n         * })\n         * export class AppComponent {\n         *   item$ = itemService.getItem();\n         * }\n         *\n         * @param boolean\n         */\n        this.renderParent = this.strategyProvider.config.parent;\n        /**\n         * @description\n         * A flag to control whether *rxLet templates are created within `NgZone` or not.\n         * The default value is `true, `*rxLet` will create it's `EmbeddedViews` inside `NgZone`.\n         *\n         * Event listeners normally trigger zone. Especially high frequently events cause performance issues.\n         *\n         * Read more about this in the\n         * [official docs](https://www.rx-angular.io/docs/template/api/let-directive#working-with-event-listeners-patchzone).\n         *\n         * @example\n         * \\@Component({\n         *   selector: 'app-root',\n         *   template: `\n         *    <app-list-component>\n         *      <app-list-item\n         *        *rxLet=\"\n         *          item$;\n         *          let item;\n         *          patchZone: false;\n         *        \"\n         *      >\n         *        <div>{{ item.name }}</div>\n         *      </app-list-item>\n         *    </app-list-component>\n         *   `\n         * })\n         * export class AppComponent {\n         *   item$ = itemService.getItem();\n         * }\n         */\n        this.patchZone = this.strategyProvider.config.patchZone;\n        /** @internal */\n        this.observablesHandler = createTemplateNotifier();\n        /** @internal */\n        this.strategyHandler = coerceAllFactory(() => new ReplaySubject(1));\n        /** @internal */\n        this.triggerHandler = new ReplaySubject(1);\n        /** @internal */\n        this.subscription = new Subscription();\n        /** @internal */\n        this.rendered$ = new Subject();\n        /** @internal */\n        this.templateNotification$ = new Subject();\n        /** @internal */\n        this.values$ = this.observablesHandler.values$;\n        this.rendered = defer(() => this.rendered$);\n    }\n    /**\n     * @description\n     *\n     * You can change the used `RenderStrategy` by using the `strategy` input of the `*rxLet`. It accepts\n     * an `Observable<RxStrategyNames>` or [`RxStrategyNames`](https://github.com/rx-angular/rx-angular/blob/b0630f69017cc1871d093e976006066d5f2005b9/libs/cdk/render-strategies/src/lib/model.ts#L52).\n     *\n     * The default value for strategy is\n     * [`normal`](https://www.rx-angular.io/docs/template/cdk/render-strategies/strategies/concurrent-strategies).\n     *\n     * Read more about this in the\n     * [official docs](https://www.rx-angular.io/docs/template/api/let-directive#use-render-strategies-strategy).\n     *\n     * @example\n     *\n     * \\@Component({\n     *   selector: 'app-root',\n     *   template: `\n     *     <ng-container *rxLet=\"hero$; let hero; strategy: strategy\">\n     *       <app-hero [hero]=\"hero\"></app-hero>\n     *     </ng-container>\n     *\n     *     <ng-container *rxLet=\"hero$; let hero; strategy: strategy$\">\n     *       <app-hero [hero]=\"hero\"></app-hero>\n     *     </ng-container>\n     *   `\n     * })\n     * export class AppComponent {\n     *   strategy = 'low';\n     *   strategy$ = of('immediate');\n     * }\n     *\n     * @param { string | Observable<string> | undefined } strategyName\n     * @see {@link RxStrategyNames}\n     */\n    set strategy(strategyName) {\n        this.strategyHandler.next(strategyName);\n    }\n    /**\n     * @description\n     * A `Subject` which emits whenever *rxFor finished rendering a set changes to the view.\n     * This enables developers to perform actions when a list has finished rendering.\n     * The `renderCallback` is useful in situations where you rely on specific DOM properties like the `height` a\n     * table after all items got rendered.\n     * It is also possible to use the renderCallback in order to determine if a view should be visible or not. This\n     * way developers can hide a list as long as it has not finished rendering.\n     *\n     * The result of the `renderCallback` will contain the currently rendered set of items in the iterable.\n     *\n     * @example\n     * \\Component({\n     *   selector: 'app-root',\n     *   template: `\n     *   <app-list-component>\n     *     <app-list-item\n     *       *rxFor=\"\n     *         let item of items$;\n     *         trackBy: trackItem;\n     *         renderCallback: itemsRendered;\n     *       \">\n     *       <div>{{ item.name }}</div>\n     *     </app-list-item>\n     *   </app-list-component>\n     * `\n     * })\n     * export class AppComponent {\n     *   items$: Observable<Item[]> = itemService.getItems();\n     *   trackItem = (idx, item) => item.id;\n     *   // this emits whenever rxFor finished rendering changes\n     *   itemsRendered = new Subject<Item[]>();\n     *\n     *   constructor(elementRef: ElementRef<HTMLElement>) {\n     *     itemsRendered.subscribe(() => {\n     *       // items are rendered, we can now scroll\n     *       elementRef.scrollTo({bottom: 0});\n     *     })\n     *   }\n     * }\n     *\n     * @param {Subject<U>} renderCallback\n     */\n    set renderCallback(callback) {\n        this._renderObserver = callback;\n    }\n    /** @internal */\n    static ngTemplateContextGuard(dir, ctx) {\n        return true;\n    }\n    /** @internal */\n    ngOnInit() {\n        this.subscription.add(this.templateManager\n            .render(merge(this.values$, this.templateNotification$))\n            .subscribe((n) => {\n            this.rendered$.next(n);\n            this._renderObserver?.next(n);\n        }));\n        this.subscription.add(merge(this.contextTrigger || NEVER, this.nextTrigger?.pipe(map(() => \"next\" /* Next */)) || NEVER, this.suspenseTrigger?.pipe(map(() => \"suspense\" /* Suspense */)) ||\n            NEVER, this.completeTrigger?.pipe(map(() => \"complete\" /* Complete */)) ||\n            NEVER, this.errorTrigger?.pipe(map(() => \"error\" /* Error */)) || NEVER)\n            .pipe(filter((v) => !!v))\n            .subscribe((t) => this.triggerHandler.next(t)));\n    }\n    /** @internal */\n    ngOnChanges(changes) {\n        if (!this.templateManager) {\n            this._createTemplateManager();\n        }\n        if (changes.complete) {\n            this.templateManager.addTemplateRef(RxLetTemplateNames.complete, this.complete);\n        }\n        if (changes.suspense) {\n            this.templateManager.addTemplateRef(RxLetTemplateNames.suspense, this.suspense);\n            this.observablesHandler.withInitialSuspense(!!this.suspense);\n        }\n        if (changes.error) {\n            this.templateManager.addTemplateRef(RxLetTemplateNames.error, this.error);\n        }\n        if (changes.rxLet) {\n            this.observablesHandler.next(this.rxLet);\n        }\n    }\n    /** @internal */\n    ngOnDestroy() {\n        this.subscription.unsubscribe();\n    }\n    /** @internal */\n    _createTemplateManager() {\n        this.templateManager = createTemplateManager({\n            templateSettings: {\n                viewContainerRef: this.viewContainerRef,\n                customContext: (rxLet) => ({ rxLet }),\n            },\n            renderSettings: {\n                cdRef: this.cdRef,\n                parent: !!this.renderParent,\n                patchZone: this.patchZone ? this.ngZone : false,\n                defaultStrategyName: this.strategyProvider.primaryStrategy,\n                strategies: this.strategyProvider.strategies,\n                errorHandler: this.errorHandler,\n            },\n            notificationToTemplateName: {\n                [\"suspense\" /* Suspense */]: () => this.suspense ? RxLetTemplateNames.suspense : RxLetTemplateNames.next,\n                [\"next\" /* Next */]: () => RxLetTemplateNames.next,\n                [\"error\" /* Error */]: () => this.error ? RxLetTemplateNames.error : RxLetTemplateNames.next,\n                [\"complete\" /* Complete */]: () => this.complete ? RxLetTemplateNames.complete : RxLetTemplateNames.next,\n            },\n            templateTrigger$: this.triggerHandler,\n        });\n        this.templateManager.addTemplateRef(RxLetTemplateNames.next, this.nextTemplateRef);\n        this.templateManager.nextStrategy(this.strategyHandler.values$);\n    }\n}\n/** @nocollapse */ LetDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: LetDirective, deps: [{ token: i1.RxStrategyProvider }, { token: i0.ChangeDetectorRef }, { token: i0.NgZone }, { token: i0.TemplateRef }, { token: i0.ViewContainerRef }, { token: i0.ErrorHandler }], target: i0.ɵɵFactoryTarget.Directive });\n/** @nocollapse */ LetDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.3.12\", type: LetDirective, selector: \"[rxLet]\", inputs: { rxLet: \"rxLet\", strategy: [\"rxLetStrategy\", \"strategy\"], complete: [\"rxLetComplete\", \"complete\"], error: [\"rxLetError\", \"error\"], suspense: [\"rxLetSuspense\", \"suspense\"], contextTrigger: [\"rxLetContextTrigger\", \"contextTrigger\"], completeTrigger: [\"rxLetCompleteTrigger\", \"completeTrigger\"], errorTrigger: [\"rxLetErrorTrigger\", \"errorTrigger\"], suspenseTrigger: [\"rxLetSuspenseTrigger\", \"suspenseTrigger\"], nextTrigger: [\"rxLetNextTrigger\", \"nextTrigger\"], renderCallback: [\"rxLetRenderCallback\", \"renderCallback\"], renderParent: [\"rxLetParent\", \"renderParent\"], patchZone: [\"rxLetPatchZone\", \"patchZone\"] }, outputs: { rendered: \"rendered\" }, usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: LetDirective, decorators: [{\n            type: Directive,\n            args: [{ selector: '[rxLet]' }]\n        }], ctorParameters: function () { return [{ type: i1.RxStrategyProvider }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i0.TemplateRef }, { type: i0.ViewContainerRef }, { type: i0.ErrorHandler }]; }, propDecorators: { rxLet: [{\n                type: Input\n            }], strategy: [{\n                type: Input,\n                args: ['rxLetStrategy']\n            }], complete: [{\n                type: Input,\n                args: ['rxLetComplete']\n            }], error: [{\n                type: Input,\n                args: ['rxLetError']\n            }], suspense: [{\n                type: Input,\n                args: ['rxLetSuspense']\n            }], contextTrigger: [{\n                type: Input,\n                args: ['rxLetContextTrigger']\n            }], completeTrigger: [{\n                type: Input,\n                args: ['rxLetCompleteTrigger']\n            }], errorTrigger: [{\n                type: Input,\n                args: ['rxLetErrorTrigger']\n            }], suspenseTrigger: [{\n                type: Input,\n                args: ['rxLetSuspenseTrigger']\n            }], nextTrigger: [{\n                type: Input,\n                args: ['rxLetNextTrigger']\n            }], renderCallback: [{\n                type: Input,\n                args: ['rxLetRenderCallback']\n            }], renderParent: [{\n                type: Input,\n                args: ['rxLetParent']\n            }], patchZone: [{\n                type: Input,\n                args: ['rxLetPatchZone']\n            }], rendered: [{\n                type: Output\n            }] } });\n\nclass LetModule {\n}\n/** @nocollapse */ LetModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: LetModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n/** @nocollapse */ LetModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: LetModule, declarations: [LetDirective], exports: [LetDirective] });\n/** @nocollapse */ LetModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: LetModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: LetModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [LetDirective],\n                    exports: [LetDirective],\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { LetDirective, LetModule };\n"],"mappings":"AAAA,OAAO,KAAKA,EAAE,MAAM,eAAe;AACnC,SAASC,SAAS,EAAEC,KAAK,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,eAAe;AAClE,SAASC,gBAAgB,QAAQ,0BAA0B;AAC3D,SAASC,sBAAsB,QAAQ,+BAA+B;AACtE,OAAO,KAAKC,EAAE,MAAM,mCAAmC;AACvD,SAASC,mBAAmB,EAAEC,qBAAqB,QAAQ,0BAA0B;AACrF,SAASC,aAAa,EAAEC,YAAY,EAAEC,OAAO,EAAEC,KAAK,EAAEC,KAAK,EAAEC,KAAK,QAAQ,MAAM;AAChF,SAASC,GAAG,EAAEC,MAAM,QAAQ,gBAAgB;;AAE5C;AACA,MAAMC,kBAAkB,GAAG;EACvB,GAAGV,mBAAmB;EACtBW,IAAI,EAAE;AACV,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,YAAY,CAAC;EACfC,WAAW,CAACC,gBAAgB,EAAEC,KAAK,EAAEC,MAAM,EAAEC,eAAe,EAAEC,gBAAgB,EAAEC,YAAY,EAAE;IAC1F,IAAI,CAACL,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACC,YAAY,GAAGA,YAAY;IAChC;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,YAAY,GAAG,IAAI,CAACN,gBAAgB,CAACO,MAAM,CAACC,MAAM;IACvD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,SAAS,GAAG,IAAI,CAACT,gBAAgB,CAACO,MAAM,CAACE,SAAS;IACvD;IACA,IAAI,CAACC,kBAAkB,GAAG1B,sBAAsB,EAAE;IAClD;IACA,IAAI,CAAC2B,eAAe,GAAG5B,gBAAgB,CAAC,MAAM,IAAIK,aAAa,CAAC,CAAC,CAAC,CAAC;IACnE;IACA,IAAI,CAACwB,cAAc,GAAG,IAAIxB,aAAa,CAAC,CAAC,CAAC;IAC1C;IACA,IAAI,CAACyB,YAAY,GAAG,IAAIxB,YAAY,EAAE;IACtC;IACA,IAAI,CAACyB,SAAS,GAAG,IAAIxB,OAAO,EAAE;IAC9B;IACA,IAAI,CAACyB,qBAAqB,GAAG,IAAIzB,OAAO,EAAE;IAC1C;IACA,IAAI,CAAC0B,OAAO,GAAG,IAAI,CAACN,kBAAkB,CAACM,OAAO;IAC9C,IAAI,CAACC,QAAQ,GAAG1B,KAAK,CAAC,MAAM,IAAI,CAACuB,SAAS,CAAC;EAC/C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAII,QAAQ,CAACC,YAAY,EAAE;IACvB,IAAI,CAACR,eAAe,CAACd,IAAI,CAACsB,YAAY,CAAC;EAC3C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIC,cAAc,CAACC,QAAQ,EAAE;IA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"},"metadata":{},"sourceType":"module","externalDependencies":[]}