{"ast":null,"code":"import { ɵglobal } from '@angular/core';\nfunction push(heap, node) {\n  const index = heap.length;\n  heap.push(node);\n  siftUp(heap, node, index);\n}\nfunction peek(heap) {\n  const first = heap[0];\n  return first === undefined ? null : first;\n}\nfunction pop(heap) {\n  const first = heap[0];\n  if (first !== undefined) {\n    const last = heap.pop();\n    if (last !== first) {\n      heap[0] = last;\n      siftDown(heap, last, 0);\n    }\n    return first;\n  } else {\n    return null;\n  }\n}\nfunction siftUp(heap, node, i) {\n  let index = i;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const parentIndex = index - 1 >>> 1;\n    const parent = heap[parentIndex];\n    if (parent !== undefined && compare(parent, node) > 0) {\n      // The parent is larger. Swap positions.\n      heap[parentIndex] = node;\n      heap[index] = parent;\n      index = parentIndex;\n    } else {\n      // The parent is smaller. Exit.\n      return;\n    }\n  }\n}\nfunction siftDown(heap, node, i) {\n  let index = i;\n  const length = heap.length;\n  while (index < length) {\n    const leftIndex = (index + 1) * 2 - 1;\n    const left = heap[leftIndex];\n    const rightIndex = leftIndex + 1;\n    const right = heap[rightIndex];\n    // If the left or right node is smaller, swap with the smaller of those.\n    if (left !== undefined && compare(left, node) < 0) {\n      if (right !== undefined && compare(right, left) < 0) {\n        heap[index] = right;\n        heap[rightIndex] = node;\n        index = rightIndex;\n      } else {\n        heap[index] = left;\n        heap[leftIndex] = node;\n        index = leftIndex;\n      }\n    } else if (right !== undefined && compare(right, node) < 0) {\n      heap[index] = right;\n      heap[rightIndex] = node;\n      index = rightIndex;\n    } else {\n      // Neither child is smaller. Exit.\n      return;\n    }\n  }\n}\nfunction compare(a, b) {\n  // Compare sort index first, then task id.\n  const diff = a.sortIndex - b.sortIndex;\n  return diff !== 0 ? diff : a.id - b.id;\n}\n\n// see https://github.com/facebook/react/blob/main/packages/scheduler/src/forks/Scheduler.js\nlet getCurrentTime;\nconst hasPerformanceNow = typeof ɵglobal.performance === 'object' && typeof ɵglobal.performance.now === 'function';\nif (hasPerformanceNow) {\n  const localPerformance = ɵglobal.performance;\n  getCurrentTime = () => localPerformance.now();\n} else {\n  const localDate = Date;\n  const initialTime = localDate.now();\n  getCurrentTime = () => localDate.now() - initialTime;\n}\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nconst maxSigned31BitInt = 1073741823;\n// Times out immediately\nconst IMMEDIATE_PRIORITY_TIMEOUT = -1;\n// Eventually times out\nconst USER_BLOCKING_PRIORITY_TIMEOUT = 250;\nconst NORMAL_PRIORITY_TIMEOUT = 5000;\nconst LOW_PRIORITY_TIMEOUT = 10000;\n// Never times out\nconst IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;\n// Tasks are stored on a min heap\nconst taskQueue = [];\nconst timerQueue = [];\n// Incrementing id counter. Used to maintain insertion order.\nlet taskIdCounter = 1;\n// Pausing the scheduler is useful for debugging.\nlet isSchedulerPaused = false;\nlet currentTask = null;\nlet currentPriorityLevel = 3 /* NormalPriority */;\n// This is set while performing work, to prevent re-entrancy.\nlet isPerformingWork = false;\nlet isHostCallbackScheduled = false;\nlet isHostTimeoutScheduled = false;\n// Capture local references to native APIs, in case a polyfill overrides them.\nconst setTimeout = ɵglobal.setTimeout;\nconst clearTimeout = ɵglobal.clearTimeout;\nconst setImmediate = ɵglobal.setImmediate; // IE and Node.js + jsdom\nconst messageChannel = ɵglobal.MessageChannel;\nconst isInputPending = typeof ɵglobal.navigator !== 'undefined' && ɵglobal.navigator.scheduling !== undefined && ɵglobal.navigator.scheduling.isInputPending !== undefined ? ɵglobal.navigator.scheduling.isInputPending.bind(ɵglobal.navigator.scheduling) : null;\nconst defaultZone = {\n  run: fn => fn()\n};\nfunction advanceTimers(currentTime) {\n  // Check for tasks that are no longer delayed and add them to the queue.\n  let timer = peek(timerQueue);\n  while (timer !== null) {\n    if (timer.callback === null) {\n      // Timer was cancelled.\n      pop(timerQueue);\n    } else if (timer.startTime <= currentTime) {\n      // Timer fired. Transfer to the task queue.\n      pop(timerQueue);\n      timer.sortIndex = timer.expirationTime;\n      push(taskQueue, timer);\n    } else {\n      // Remaining timers are pending.\n      return;\n    }\n    timer = peek(timerQueue);\n  }\n}\nfunction handleTimeout(currentTime) {\n  isHostTimeoutScheduled = false;\n  advanceTimers(currentTime);\n  if (!isHostCallbackScheduled) {\n    if (peek(taskQueue) !== null) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    } else {\n      const firstTimer = peek(timerQueue);\n      if (firstTimer !== null) {\n        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n      }\n    }\n  }\n}\nfunction flushWork(hasTimeRemaining, initialTime) {\n  // We'll need a host callback the next time work is scheduled.\n  isHostCallbackScheduled = false;\n  if (isHostTimeoutScheduled) {\n    // We scheduled a timeout but it's no longer needed. Cancel it.\n    isHostTimeoutScheduled = false;\n    cancelHostTimeout();\n  }\n  isPerformingWork = true;\n  const previousPriorityLevel = currentPriorityLevel;\n  try {\n    return workLoop(hasTimeRemaining, initialTime);\n  } finally {\n    currentTask = null;\n    currentPriorityLevel = previousPriorityLevel;\n    isPerformingWork = false;\n  }\n}\nfunction workLoop(hasTimeRemaining, initialTime, _currentTask) {\n  let currentTime = initialTime;\n  if (_currentTask) {\n    currentTask = _currentTask;\n  } else {\n    advanceTimers(currentTime);\n    currentTask = peek(taskQueue);\n  }\n  let zoneChanged = false;\n  const hitDeadline = () => currentTask && currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost());\n  if (!hitDeadline()) {\n    const ngZone = currentTask.ngZone || defaultZone;\n    ngZone.run(() => {\n      while (currentTask !== null && !zoneChanged) {\n        if (hitDeadline()) {\n          break;\n        }\n        const callback = currentTask.callback;\n        if (typeof callback === 'function') {\n          currentTask.callback = null;\n          currentPriorityLevel = currentTask.priorityLevel;\n          const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n          const continuationCallback = callback(didUserCallbackTimeout);\n          currentTime = getCurrentTime();\n          if (typeof continuationCallback === 'function') {\n            currentTask.callback = continuationCallback;\n          } else {\n            if (currentTask === peek(taskQueue)) {\n              pop(taskQueue);\n            }\n          }\n          advanceTimers(currentTime);\n        } else {\n          pop(taskQueue);\n        }\n        currentTask = peek(taskQueue);\n        zoneChanged = currentTask?.ngZone != null && currentTask.ngZone !== ngZone;\n      }\n    });\n  }\n  // we need to check if leaving `NgZone` (tick => detectChanges) caused other\n  // directives to add tasks to the queue. If there is one and we still didn't\n  // hit the deadline, run the workLoop again in order to flush everything thats\n  // left.\n  // Otherwise, newly added tasks won't run as `performingWork` is still `true`\n  currentTask = currentTask ?? peek(taskQueue);\n  // We should also re-calculate the currentTime, as we need to account for the execution\n  // time of the NgZone tasks as well.\n  // If there is still a task in the queue, but no time is left for executing it,\n  // the scheduler will re-schedule the next tick anyway\n  currentTime = getCurrentTime();\n  if (zoneChanged || currentTask && !hitDeadline()) {\n    return workLoop(hasTimeRemaining, currentTime, currentTask);\n  }\n  // Return whether there's additional work\n  if (currentTask !== null) {\n    return true;\n  } else {\n    const firstTimer = peek(timerQueue);\n    if (firstTimer !== null) {\n      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n    }\n    return false;\n  }\n}\nfunction runWithPriority(priorityLevel, eventHandler) {\n  switch (priorityLevel) {\n    case 1 /* ImmediatePriority */:\n    case 2 /* UserBlockingPriority */:\n    case 3 /* NormalPriority */:\n    case 4 /* LowPriority */:\n    case 5 /* IdlePriority */:\n      break;\n    default:\n      priorityLevel = 3 /* NormalPriority */;\n  }\n\n  const previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n}\nfunction next(eventHandler) {\n  let priorityLevel;\n  switch (currentPriorityLevel) {\n    case 1 /* ImmediatePriority */:\n    case 2 /* UserBlockingPriority */:\n    case 3 /* NormalPriority */:\n      // Shift down to normal priority\n      priorityLevel = 3 /* NormalPriority */;\n      break;\n    default:\n      // Anything lower than normal priority should remain at the current level.\n      priorityLevel = currentPriorityLevel;\n      break;\n  }\n  const previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n}\nfunction wrapCallback(callback) {\n  const parentPriorityLevel = currentPriorityLevel;\n  return () => {\n    // This is a fork of runWithPriority, inlined for performance.\n    const previousPriorityLevel = currentPriorityLevel;\n    currentPriorityLevel = parentPriorityLevel;\n    try {\n      // eslint-disable-next-line prefer-rest-params\n      return callback.apply(this, arguments);\n    } finally {\n      currentPriorityLevel = previousPriorityLevel;\n    }\n  };\n}\nfunction scheduleCallback(priorityLevel, callback, options) {\n  const currentTime = getCurrentTime();\n  let startTime;\n  if (typeof options === 'object' && options !== null) {\n    const delay = options.delay;\n    if (typeof delay === 'number' && delay > 0) {\n      startTime = currentTime + delay;\n    } else {\n      startTime = currentTime;\n    }\n  } else {\n    startTime = currentTime;\n  }\n  let timeout;\n  switch (priorityLevel) {\n    case 1 /* ImmediatePriority */:\n      timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n      break;\n    case 2 /* UserBlockingPriority */:\n      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n      break;\n    case 5 /* IdlePriority */:\n      timeout = IDLE_PRIORITY_TIMEOUT;\n      break;\n    case 4 /* LowPriority */:\n      timeout = LOW_PRIORITY_TIMEOUT;\n      break;\n    case 3 /* NormalPriority */:\n    default:\n      timeout = NORMAL_PRIORITY_TIMEOUT;\n      break;\n  }\n  const expirationTime = startTime + timeout;\n  const newTask = {\n    id: taskIdCounter++,\n    callback,\n    priorityLevel,\n    startTime,\n    expirationTime,\n    sortIndex: -1,\n    ngZone: options?.ngZone || null\n  };\n  if (startTime > currentTime) {\n    // This is a delayed task.\n    newTask.sortIndex = startTime;\n    push(timerQueue, newTask);\n    if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n      // All tasks are delayed, and this is the task with the earliest delay.\n      if (isHostTimeoutScheduled) {\n        // Cancel an existing timeout.\n        cancelHostTimeout();\n      } else {\n        isHostTimeoutScheduled = true;\n      }\n      // Schedule a timeout.\n      requestHostTimeout(handleTimeout, startTime - currentTime);\n    }\n  } else {\n    newTask.sortIndex = expirationTime;\n    push(taskQueue, newTask);\n    // Schedule a host callback, if needed. If we're already performing work,\n    // wait until the next time we yield.\n    if (!isHostCallbackScheduled && !isPerformingWork) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    }\n  }\n  return newTask;\n}\nfunction pauseExecution() {\n  isSchedulerPaused = true;\n}\nfunction continueExecution() {\n  isSchedulerPaused = false;\n  if (!isHostCallbackScheduled && !isPerformingWork) {\n    isHostCallbackScheduled = true;\n    requestHostCallback(flushWork);\n  }\n}\nfunction getFirstCallbackNode() {\n  return peek(taskQueue);\n}\nfunction cancelCallback(task) {\n  // Null out the callback to indicate the task has been canceled. (Can't\n  // remove from the queue because you can't remove arbitrary nodes from an\n  // array based heap, only the first one.)\n  task.callback = null;\n}\nfunction getCurrentPriorityLevel() {\n  return currentPriorityLevel;\n}\nlet isMessageLoopRunning = false;\nlet scheduledHostCallback = null;\nlet taskTimeoutID = -1;\n// Scheduler periodically yields in case there is other work on the main\n// thread, like user events. By default, it yields multiple times per frame.\n// It does not attempt to align with frame boundaries, since most tasks don't\n// need to be frame aligned; for those that do, use requestAnimationFrame.\nlet yieldInterval = 16;\n// TODO: Make this configurable\n// TODO: Adjust this based on priority?\nconst maxYieldInterval = 300;\nlet needsPaint = false;\nlet queueStartTime = -1;\nfunction shouldYieldToHost() {\n  if (needsPaint) {\n    // There's a pending paint (signaled by `requestPaint`). Yield now.\n    return true;\n  }\n  const timeElapsed = getCurrentTime() - queueStartTime;\n  if (timeElapsed < yieldInterval) {\n    // The main thread has only been blocked for a really short amount of time;\n    // smaller than a single frame. Don't yield yet.\n    return false;\n  }\n  // The main thread has been blocked for a non-negligible amount of time. We\n  // may want to yield control of the main thread, so the browser can perform\n  // high priority tasks. The main ones are painting and user input. If there's\n  // a pending paint or a pending input, then we should yield. But if there's\n  // neither, then we can yield less often while remaining responsive. We'll\n  // eventually yield regardless, since there could be a pending paint that\n  // wasn't accompanied by a call to `requestPaint`, or other main thread tasks\n  // like network events.\n  // we don't support isInputPending currently\n  /*if (enableIsInputPending) {\n    if (needsPaint) {\n      // There's a pending paint (signaled by `requestPaint`). Yield now.\n      return true;\n    }\n    if (timeElapsed < continuousInputInterval) {\n      // We haven't blocked the thread for that long. Only yield if there's a\n      // pending discrete input (e.g. click). It's OK if there's pending\n      // continuous input (e.g. mouseover).\n      if (isInputPending !== null) {\n        return isInputPending();\n      }\n    } else if (timeElapsed < maxInterval) {\n      // Yield if there's either a pending discrete or continuous input.\n      if (isInputPending !== null) {\n        return isInputPending(continuousOptions);\n      }\n    } else {\n      // We've blocked the thread for a long time. Even if there's no pending\n      // input, there may be some other scheduled work that we don't know about,\n      // like a network event. Yield now.\n      return true;\n    }\n  }*/\n  // `isInputPending` isn't available. Yield now.\n  return true;\n}\nfunction requestPaint() {\n  needsPaint = true;\n  // we don't support isInputPending currently\n  /*if (\n    enableIsInputPending &&\n    navigator !== undefined &&\n    (navigator as any).scheduling !== undefined &&\n    (navigator as any).scheduling.isInputPending !== undefined\n  ) {\n    needsPaint = true;\n  }*/\n}\n\nfunction forceFrameRate(fps) {\n  if (fps < 0 || fps > 125) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      console.error('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');\n    }\n    return;\n  }\n  if (fps > 0) {\n    yieldInterval = Math.floor(1000 / fps);\n  } else {\n    // reset the framerate\n    yieldInterval = 5;\n  }\n  // be aware of browser housekeeping work (~6ms per frame)\n  // according to https://developers.google.com/web/fundamentals/performance/rendering\n  yieldInterval = Math.max(5, yieldInterval - 6);\n}\nconst performWorkUntilDeadline = () => {\n  if (scheduledHostCallback !== null) {\n    const currentTime = getCurrentTime();\n    // Yield after `yieldInterval` ms, regardless of where we are in the vsync\n    // cycle. This means there's always time remaining at the beginning of\n    // the message event.\n    queueStartTime = currentTime;\n    const hasTimeRemaining = true;\n    // If a scheduler task throws, exit the current browser task so the\n    // error can be observed.\n    //\n    // Intentionally not using a try-catch, since that makes some debugging\n    // techniques harder. Instead, if `scheduledHostCallback` errors, then\n    // `hasMoreWork` will remain true, and we'll continue the work loop.\n    let hasMoreWork = true;\n    try {\n      hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n    } finally {\n      if (hasMoreWork) {\n        // If there's more work, schedule the next message event at the end\n        // of the preceding one.\n        schedulePerformWorkUntilDeadline();\n      } else {\n        isMessageLoopRunning = false;\n        scheduledHostCallback = null;\n      }\n    }\n  } else {\n    isMessageLoopRunning = false;\n  }\n  // Yielding to the browser will give it a chance to paint, so we can\n  // reset this.\n  needsPaint = false;\n};\nlet schedulePerformWorkUntilDeadline;\nif (typeof setImmediate === 'function') {\n  // Node.js and old IE.\n  // There's a few reasons for why we prefer setImmediate.\n  //\n  // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.\n  // (Even though this is a DOM fork of the Scheduler, you could get here\n  // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)\n  // https://github.com/facebook/react/issues/20756\n  //\n  // But also, it runs earlier which is the semantic we want.\n  // If other browsers ever implement it, it's better to use it.\n  // Although both of these would be inferior to native scheduling.\n  schedulePerformWorkUntilDeadline = () => {\n    setImmediate(performWorkUntilDeadline);\n  };\n} else if (typeof messageChannel !== 'undefined') {\n  const channel = new messageChannel();\n  const port = channel.port2;\n  channel.port1.onmessage = performWorkUntilDeadline;\n  schedulePerformWorkUntilDeadline = () => {\n    port.postMessage(null);\n  };\n} else {\n  // We should only fallback here in non-browser environments.\n  schedulePerformWorkUntilDeadline = () => {\n    setTimeout(performWorkUntilDeadline, 0);\n  };\n}\nfunction requestHostCallback(callback) {\n  scheduledHostCallback = callback;\n  if (!isMessageLoopRunning) {\n    isMessageLoopRunning = true;\n    schedulePerformWorkUntilDeadline();\n  }\n}\nfunction requestHostTimeout(callback, ms) {\n  taskTimeoutID = setTimeout(() => {\n    callback(getCurrentTime());\n  }, ms);\n}\nfunction cancelHostTimeout() {\n  clearTimeout(taskTimeoutID);\n  taskTimeoutID = -1;\n}\nconst _requestPaint = requestPaint;\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { cancelCallback, forceFrameRate, scheduleCallback };","map":{"version":3,"names":["ɵglobal","push","heap","node","index","length","siftUp","peek","first","undefined","pop","last","siftDown","i","parentIndex","parent","compare","leftIndex","left","rightIndex","right","a","b","diff","sortIndex","id","getCurrentTime","hasPerformanceNow","performance","now","localPerformance","localDate","Date","initialTime","maxSigned31BitInt","IMMEDIATE_PRIORITY_TIMEOUT","USER_BLOCKING_PRIORITY_TIMEOUT","NORMAL_PRIORITY_TIMEOUT","LOW_PRIORITY_TIMEOUT","IDLE_PRIORITY_TIMEOUT","taskQueue","timerQueue","taskIdCounter","isSchedulerPaused","currentTask","currentPriorityLevel","isPerformingWork","isHostCallbackScheduled","isHostTimeoutScheduled","setTimeout","clearTimeout","setImmediate","messageChannel","MessageChannel","isInputPending","navigator","scheduling","bind","defaultZone","run","fn","advanceTimers","currentTime","timer","callback","startTime","expirationTime","handleTimeout","requestHostCallback","flushWork","firstTimer","requestHostTimeout","hasTimeRemaining","cancelHostTimeout","previousPriorityLevel","workLoop","_currentTask","zoneChanged","hitDeadline","shouldYieldToHost","ngZone","priorityLevel","didUserCallbackTimeout","continuationCallback","runWithPriority","eventHandler","next","wrapCallback","parentPriorityLevel","apply","arguments","scheduleCallback","options","delay","timeout","newTask","pauseExecution","continueExecution","getFirstCallbackNode","cancelCallback","task","getCurrentPriorityLevel","isMessageLoopRunning","scheduledHostCallback","taskTimeoutID","yieldInterval","maxYieldInterval","needsPaint","queueStartTime","timeElapsed","requestPaint","forceFrameRate","fps","ngDevMode","console","error","Math","floor","max","performWorkUntilDeadline","hasMoreWork","schedulePerformWorkUntilDeadline","channel","port","port2","port1","onmessage","postMessage","ms","_requestPaint"],"sources":["C:/Development/AngularComponent/ClientApp/node_modules/@rx-angular/cdk/fesm2020/cdk-internals-scheduler.mjs"],"sourcesContent":["import { ɵglobal } from '@angular/core';\n\nfunction push(heap, node) {\n    const index = heap.length;\n    heap.push(node);\n    siftUp(heap, node, index);\n}\nfunction peek(heap) {\n    const first = heap[0];\n    return first === undefined ? null : first;\n}\nfunction pop(heap) {\n    const first = heap[0];\n    if (first !== undefined) {\n        const last = heap.pop();\n        if (last !== first) {\n            heap[0] = last;\n            siftDown(heap, last, 0);\n        }\n        return first;\n    }\n    else {\n        return null;\n    }\n}\nfunction siftUp(heap, node, i) {\n    let index = i;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const parentIndex = (index - 1) >>> 1;\n        const parent = heap[parentIndex];\n        if (parent !== undefined && compare(parent, node) > 0) {\n            // The parent is larger. Swap positions.\n            heap[parentIndex] = node;\n            heap[index] = parent;\n            index = parentIndex;\n        }\n        else {\n            // The parent is smaller. Exit.\n            return;\n        }\n    }\n}\nfunction siftDown(heap, node, i) {\n    let index = i;\n    const length = heap.length;\n    while (index < length) {\n        const leftIndex = (index + 1) * 2 - 1;\n        const left = heap[leftIndex];\n        const rightIndex = leftIndex + 1;\n        const right = heap[rightIndex];\n        // If the left or right node is smaller, swap with the smaller of those.\n        if (left !== undefined && compare(left, node) < 0) {\n            if (right !== undefined && compare(right, left) < 0) {\n                heap[index] = right;\n                heap[rightIndex] = node;\n                index = rightIndex;\n            }\n            else {\n                heap[index] = left;\n                heap[leftIndex] = node;\n                index = leftIndex;\n            }\n        }\n        else if (right !== undefined && compare(right, node) < 0) {\n            heap[index] = right;\n            heap[rightIndex] = node;\n            index = rightIndex;\n        }\n        else {\n            // Neither child is smaller. Exit.\n            return;\n        }\n    }\n}\nfunction compare(a, b) {\n    // Compare sort index first, then task id.\n    const diff = a.sortIndex - b.sortIndex;\n    return diff !== 0 ? diff : a.id - b.id;\n}\n\n// see https://github.com/facebook/react/blob/main/packages/scheduler/src/forks/Scheduler.js\nlet getCurrentTime;\nconst hasPerformanceNow = typeof ɵglobal.performance === 'object' &&\n    typeof ɵglobal.performance.now === 'function';\nif (hasPerformanceNow) {\n    const localPerformance = ɵglobal.performance;\n    getCurrentTime = () => localPerformance.now();\n}\nelse {\n    const localDate = Date;\n    const initialTime = localDate.now();\n    getCurrentTime = () => localDate.now() - initialTime;\n}\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nconst maxSigned31BitInt = 1073741823;\n// Times out immediately\nconst IMMEDIATE_PRIORITY_TIMEOUT = -1;\n// Eventually times out\nconst USER_BLOCKING_PRIORITY_TIMEOUT = 250;\nconst NORMAL_PRIORITY_TIMEOUT = 5000;\nconst LOW_PRIORITY_TIMEOUT = 10000;\n// Never times out\nconst IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;\n// Tasks are stored on a min heap\nconst taskQueue = [];\nconst timerQueue = [];\n// Incrementing id counter. Used to maintain insertion order.\nlet taskIdCounter = 1;\n// Pausing the scheduler is useful for debugging.\nlet isSchedulerPaused = false;\nlet currentTask = null;\nlet currentPriorityLevel = 3 /* NormalPriority */;\n// This is set while performing work, to prevent re-entrancy.\nlet isPerformingWork = false;\nlet isHostCallbackScheduled = false;\nlet isHostTimeoutScheduled = false;\n// Capture local references to native APIs, in case a polyfill overrides them.\nconst setTimeout = ɵglobal.setTimeout;\nconst clearTimeout = ɵglobal.clearTimeout;\nconst setImmediate = ɵglobal.setImmediate; // IE and Node.js + jsdom\nconst messageChannel = ɵglobal.MessageChannel;\nconst isInputPending = typeof ɵglobal.navigator !== 'undefined' &&\n    ɵglobal.navigator.scheduling !== undefined &&\n    ɵglobal.navigator.scheduling.isInputPending !== undefined\n    ? ɵglobal.navigator.scheduling.isInputPending.bind(ɵglobal.navigator.scheduling)\n    : null;\nconst defaultZone = {\n    run: (fn) => fn(),\n};\nfunction advanceTimers(currentTime) {\n    // Check for tasks that are no longer delayed and add them to the queue.\n    let timer = peek(timerQueue);\n    while (timer !== null) {\n        if (timer.callback === null) {\n            // Timer was cancelled.\n            pop(timerQueue);\n        }\n        else if (timer.startTime <= currentTime) {\n            // Timer fired. Transfer to the task queue.\n            pop(timerQueue);\n            timer.sortIndex = timer.expirationTime;\n            push(taskQueue, timer);\n        }\n        else {\n            // Remaining timers are pending.\n            return;\n        }\n        timer = peek(timerQueue);\n    }\n}\nfunction handleTimeout(currentTime) {\n    isHostTimeoutScheduled = false;\n    advanceTimers(currentTime);\n    if (!isHostCallbackScheduled) {\n        if (peek(taskQueue) !== null) {\n            isHostCallbackScheduled = true;\n            requestHostCallback(flushWork);\n        }\n        else {\n            const firstTimer = peek(timerQueue);\n            if (firstTimer !== null) {\n                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n            }\n        }\n    }\n}\nfunction flushWork(hasTimeRemaining, initialTime) {\n    // We'll need a host callback the next time work is scheduled.\n    isHostCallbackScheduled = false;\n    if (isHostTimeoutScheduled) {\n        // We scheduled a timeout but it's no longer needed. Cancel it.\n        isHostTimeoutScheduled = false;\n        cancelHostTimeout();\n    }\n    isPerformingWork = true;\n    const previousPriorityLevel = currentPriorityLevel;\n    try {\n        return workLoop(hasTimeRemaining, initialTime);\n    }\n    finally {\n        currentTask = null;\n        currentPriorityLevel = previousPriorityLevel;\n        isPerformingWork = false;\n    }\n}\nfunction workLoop(hasTimeRemaining, initialTime, _currentTask) {\n    let currentTime = initialTime;\n    if (_currentTask) {\n        currentTask = _currentTask;\n    }\n    else {\n        advanceTimers(currentTime);\n        currentTask = peek(taskQueue);\n    }\n    let zoneChanged = false;\n    const hitDeadline = () => currentTask &&\n        currentTask.expirationTime > currentTime &&\n        (!hasTimeRemaining || shouldYieldToHost());\n    if (!hitDeadline()) {\n        const ngZone = currentTask.ngZone || defaultZone;\n        ngZone.run(() => {\n            while (currentTask !== null && !zoneChanged) {\n                if (hitDeadline()) {\n                    break;\n                }\n                const callback = currentTask.callback;\n                if (typeof callback === 'function') {\n                    currentTask.callback = null;\n                    currentPriorityLevel = currentTask.priorityLevel;\n                    const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n                    const continuationCallback = callback(didUserCallbackTimeout);\n                    currentTime = getCurrentTime();\n                    if (typeof continuationCallback === 'function') {\n                        currentTask.callback = continuationCallback;\n                    }\n                    else {\n                        if (currentTask === peek(taskQueue)) {\n                            pop(taskQueue);\n                        }\n                    }\n                    advanceTimers(currentTime);\n                }\n                else {\n                    pop(taskQueue);\n                }\n                currentTask = peek(taskQueue);\n                zoneChanged =\n                    currentTask?.ngZone != null && currentTask.ngZone !== ngZone;\n            }\n        });\n    }\n    // we need to check if leaving `NgZone` (tick => detectChanges) caused other\n    // directives to add tasks to the queue. If there is one and we still didn't\n    // hit the deadline, run the workLoop again in order to flush everything thats\n    // left.\n    // Otherwise, newly added tasks won't run as `performingWork` is still `true`\n    currentTask = currentTask ?? peek(taskQueue);\n    // We should also re-calculate the currentTime, as we need to account for the execution\n    // time of the NgZone tasks as well.\n    // If there is still a task in the queue, but no time is left for executing it,\n    // the scheduler will re-schedule the next tick anyway\n    currentTime = getCurrentTime();\n    if (zoneChanged || (currentTask && !hitDeadline())) {\n        return workLoop(hasTimeRemaining, currentTime, currentTask);\n    }\n    // Return whether there's additional work\n    if (currentTask !== null) {\n        return true;\n    }\n    else {\n        const firstTimer = peek(timerQueue);\n        if (firstTimer !== null) {\n            requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n        }\n        return false;\n    }\n}\nfunction runWithPriority(priorityLevel, eventHandler) {\n    switch (priorityLevel) {\n        case 1 /* ImmediatePriority */:\n        case 2 /* UserBlockingPriority */:\n        case 3 /* NormalPriority */:\n        case 4 /* LowPriority */:\n        case 5 /* IdlePriority */:\n            break;\n        default:\n            priorityLevel = 3 /* NormalPriority */;\n    }\n    const previousPriorityLevel = currentPriorityLevel;\n    currentPriorityLevel = priorityLevel;\n    try {\n        return eventHandler();\n    }\n    finally {\n        currentPriorityLevel = previousPriorityLevel;\n    }\n}\nfunction next(eventHandler) {\n    let priorityLevel;\n    switch (currentPriorityLevel) {\n        case 1 /* ImmediatePriority */:\n        case 2 /* UserBlockingPriority */:\n        case 3 /* NormalPriority */:\n            // Shift down to normal priority\n            priorityLevel = 3 /* NormalPriority */;\n            break;\n        default:\n            // Anything lower than normal priority should remain at the current level.\n            priorityLevel = currentPriorityLevel;\n            break;\n    }\n    const previousPriorityLevel = currentPriorityLevel;\n    currentPriorityLevel = priorityLevel;\n    try {\n        return eventHandler();\n    }\n    finally {\n        currentPriorityLevel = previousPriorityLevel;\n    }\n}\nfunction wrapCallback(callback) {\n    const parentPriorityLevel = currentPriorityLevel;\n    return () => {\n        // This is a fork of runWithPriority, inlined for performance.\n        const previousPriorityLevel = currentPriorityLevel;\n        currentPriorityLevel = parentPriorityLevel;\n        try {\n            // eslint-disable-next-line prefer-rest-params\n            return callback.apply(this, arguments);\n        }\n        finally {\n            currentPriorityLevel = previousPriorityLevel;\n        }\n    };\n}\nfunction scheduleCallback(priorityLevel, callback, options) {\n    const currentTime = getCurrentTime();\n    let startTime;\n    if (typeof options === 'object' && options !== null) {\n        const delay = options.delay;\n        if (typeof delay === 'number' && delay > 0) {\n            startTime = currentTime + delay;\n        }\n        else {\n            startTime = currentTime;\n        }\n    }\n    else {\n        startTime = currentTime;\n    }\n    let timeout;\n    switch (priorityLevel) {\n        case 1 /* ImmediatePriority */:\n            timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n            break;\n        case 2 /* UserBlockingPriority */:\n            timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n            break;\n        case 5 /* IdlePriority */:\n            timeout = IDLE_PRIORITY_TIMEOUT;\n            break;\n        case 4 /* LowPriority */:\n            timeout = LOW_PRIORITY_TIMEOUT;\n            break;\n        case 3 /* NormalPriority */:\n        default:\n            timeout = NORMAL_PRIORITY_TIMEOUT;\n            break;\n    }\n    const expirationTime = startTime + timeout;\n    const newTask = {\n        id: taskIdCounter++,\n        callback,\n        priorityLevel,\n        startTime,\n        expirationTime,\n        sortIndex: -1,\n        ngZone: options?.ngZone || null,\n    };\n    if (startTime > currentTime) {\n        // This is a delayed task.\n        newTask.sortIndex = startTime;\n        push(timerQueue, newTask);\n        if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n            // All tasks are delayed, and this is the task with the earliest delay.\n            if (isHostTimeoutScheduled) {\n                // Cancel an existing timeout.\n                cancelHostTimeout();\n            }\n            else {\n                isHostTimeoutScheduled = true;\n            }\n            // Schedule a timeout.\n            requestHostTimeout(handleTimeout, startTime - currentTime);\n        }\n    }\n    else {\n        newTask.sortIndex = expirationTime;\n        push(taskQueue, newTask);\n        // Schedule a host callback, if needed. If we're already performing work,\n        // wait until the next time we yield.\n        if (!isHostCallbackScheduled && !isPerformingWork) {\n            isHostCallbackScheduled = true;\n            requestHostCallback(flushWork);\n        }\n    }\n    return newTask;\n}\nfunction pauseExecution() {\n    isSchedulerPaused = true;\n}\nfunction continueExecution() {\n    isSchedulerPaused = false;\n    if (!isHostCallbackScheduled && !isPerformingWork) {\n        isHostCallbackScheduled = true;\n        requestHostCallback(flushWork);\n    }\n}\nfunction getFirstCallbackNode() {\n    return peek(taskQueue);\n}\nfunction cancelCallback(task) {\n    // Null out the callback to indicate the task has been canceled. (Can't\n    // remove from the queue because you can't remove arbitrary nodes from an\n    // array based heap, only the first one.)\n    task.callback = null;\n}\nfunction getCurrentPriorityLevel() {\n    return currentPriorityLevel;\n}\nlet isMessageLoopRunning = false;\nlet scheduledHostCallback = null;\nlet taskTimeoutID = -1;\n// Scheduler periodically yields in case there is other work on the main\n// thread, like user events. By default, it yields multiple times per frame.\n// It does not attempt to align with frame boundaries, since most tasks don't\n// need to be frame aligned; for those that do, use requestAnimationFrame.\nlet yieldInterval = 16;\n// TODO: Make this configurable\n// TODO: Adjust this based on priority?\nconst maxYieldInterval = 300;\nlet needsPaint = false;\nlet queueStartTime = -1;\nfunction shouldYieldToHost() {\n    if (needsPaint) {\n        // There's a pending paint (signaled by `requestPaint`). Yield now.\n        return true;\n    }\n    const timeElapsed = getCurrentTime() - queueStartTime;\n    if (timeElapsed < yieldInterval) {\n        // The main thread has only been blocked for a really short amount of time;\n        // smaller than a single frame. Don't yield yet.\n        return false;\n    }\n    // The main thread has been blocked for a non-negligible amount of time. We\n    // may want to yield control of the main thread, so the browser can perform\n    // high priority tasks. The main ones are painting and user input. If there's\n    // a pending paint or a pending input, then we should yield. But if there's\n    // neither, then we can yield less often while remaining responsive. We'll\n    // eventually yield regardless, since there could be a pending paint that\n    // wasn't accompanied by a call to `requestPaint`, or other main thread tasks\n    // like network events.\n    // we don't support isInputPending currently\n    /*if (enableIsInputPending) {\n      if (needsPaint) {\n        // There's a pending paint (signaled by `requestPaint`). Yield now.\n        return true;\n      }\n      if (timeElapsed < continuousInputInterval) {\n        // We haven't blocked the thread for that long. Only yield if there's a\n        // pending discrete input (e.g. click). It's OK if there's pending\n        // continuous input (e.g. mouseover).\n        if (isInputPending !== null) {\n          return isInputPending();\n        }\n      } else if (timeElapsed < maxInterval) {\n        // Yield if there's either a pending discrete or continuous input.\n        if (isInputPending !== null) {\n          return isInputPending(continuousOptions);\n        }\n      } else {\n        // We've blocked the thread for a long time. Even if there's no pending\n        // input, there may be some other scheduled work that we don't know about,\n        // like a network event. Yield now.\n        return true;\n      }\n    }*/\n    // `isInputPending` isn't available. Yield now.\n    return true;\n}\nfunction requestPaint() {\n    needsPaint = true;\n    // we don't support isInputPending currently\n    /*if (\n      enableIsInputPending &&\n      navigator !== undefined &&\n      (navigator as any).scheduling !== undefined &&\n      (navigator as any).scheduling.isInputPending !== undefined\n    ) {\n      needsPaint = true;\n    }*/\n}\nfunction forceFrameRate(fps) {\n    if (fps < 0 || fps > 125) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            console.error('forceFrameRate takes a positive int between 0 and 125, ' +\n                'forcing frame rates higher than 125 fps is not supported');\n        }\n        return;\n    }\n    if (fps > 0) {\n        yieldInterval = Math.floor(1000 / fps);\n    }\n    else {\n        // reset the framerate\n        yieldInterval = 5;\n    }\n    // be aware of browser housekeeping work (~6ms per frame)\n    // according to https://developers.google.com/web/fundamentals/performance/rendering\n    yieldInterval = Math.max(5, yieldInterval - 6);\n}\nconst performWorkUntilDeadline = () => {\n    if (scheduledHostCallback !== null) {\n        const currentTime = getCurrentTime();\n        // Yield after `yieldInterval` ms, regardless of where we are in the vsync\n        // cycle. This means there's always time remaining at the beginning of\n        // the message event.\n        queueStartTime = currentTime;\n        const hasTimeRemaining = true;\n        // If a scheduler task throws, exit the current browser task so the\n        // error can be observed.\n        //\n        // Intentionally not using a try-catch, since that makes some debugging\n        // techniques harder. Instead, if `scheduledHostCallback` errors, then\n        // `hasMoreWork` will remain true, and we'll continue the work loop.\n        let hasMoreWork = true;\n        try {\n            hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n        }\n        finally {\n            if (hasMoreWork) {\n                // If there's more work, schedule the next message event at the end\n                // of the preceding one.\n                schedulePerformWorkUntilDeadline();\n            }\n            else {\n                isMessageLoopRunning = false;\n                scheduledHostCallback = null;\n            }\n        }\n    }\n    else {\n        isMessageLoopRunning = false;\n    }\n    // Yielding to the browser will give it a chance to paint, so we can\n    // reset this.\n    needsPaint = false;\n};\nlet schedulePerformWorkUntilDeadline;\nif (typeof setImmediate === 'function') {\n    // Node.js and old IE.\n    // There's a few reasons for why we prefer setImmediate.\n    //\n    // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.\n    // (Even though this is a DOM fork of the Scheduler, you could get here\n    // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)\n    // https://github.com/facebook/react/issues/20756\n    //\n    // But also, it runs earlier which is the semantic we want.\n    // If other browsers ever implement it, it's better to use it.\n    // Although both of these would be inferior to native scheduling.\n    schedulePerformWorkUntilDeadline = () => {\n        setImmediate(performWorkUntilDeadline);\n    };\n}\nelse if (typeof messageChannel !== 'undefined') {\n    const channel = new messageChannel();\n    const port = channel.port2;\n    channel.port1.onmessage = performWorkUntilDeadline;\n    schedulePerformWorkUntilDeadline = () => {\n        port.postMessage(null);\n    };\n}\nelse {\n    // We should only fallback here in non-browser environments.\n    schedulePerformWorkUntilDeadline = () => {\n        setTimeout(performWorkUntilDeadline, 0);\n    };\n}\nfunction requestHostCallback(callback) {\n    scheduledHostCallback = callback;\n    if (!isMessageLoopRunning) {\n        isMessageLoopRunning = true;\n        schedulePerformWorkUntilDeadline();\n    }\n}\nfunction requestHostTimeout(callback, ms) {\n    taskTimeoutID = setTimeout(() => {\n        callback(getCurrentTime());\n    }, ms);\n}\nfunction cancelHostTimeout() {\n    clearTimeout(taskTimeoutID);\n    taskTimeoutID = -1;\n}\nconst _requestPaint = requestPaint;\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { cancelCallback, forceFrameRate, scheduleCallback };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}