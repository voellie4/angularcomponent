{"ast":null,"code":"import { ɵglobal } from '@angular/core';\nimport { Observable, from, combineLatest } from 'rxjs';\nimport { concatMap, mapTo, filter, distinctUntilChanged, map, shareReplay } from 'rxjs/operators';\nimport { coalesceWith } from '@rx-angular/cdk/coalescing';\nfunction getZoneUnPatchedApi(targetOrName, name) {\n  // If the user has provided the API name as the first argument, for instance:\n  // `const addEventListener = getZoneUnPatchedApi('addEventListener');`\n  // Then we just swap arguments and make `global` or `window` as the default target.\n  if (typeof targetOrName === 'string') {\n    name = targetOrName;\n    targetOrName = ɵglobal;\n  }\n  return targetOrName['__zone_symbol__' + name] || targetOrName[name];\n}\n\n/**\n * Creates an Observable that emits after a setTimeout.\n * The timeout it unpatched to not avoid zone pollution\n * @param setTimeoutFn\n */\nfunction timeout(delay = 0) {\n  return new Observable(subscriber => {\n    const asyncID = getZoneUnPatchedApi('setTimeout')(() => subscriber.next(0), delay);\n    return () => {\n      getZoneUnPatchedApi('clearTimeout')(asyncID);\n    };\n  });\n}\n/**\n *\n */\nfunction timeoutSwitchMapWith() {\n  return o$ => o$.pipe(concatMap(v => timeout().pipe(mapTo(v))));\n}\nconst resolvedPromise = getZoneUnPatchedApi('Promise').resolve();\nconst resolvedPromise$ = from(resolvedPromise);\n/**\n * @internal\n *\n * Used for typing\n */\nfunction getEntriesToObjectReducerFn(keys) {\n  return (accumulator, currentValue, currentIndex) => {\n    return {\n      ...accumulator,\n      [keys[currentIndex]]: currentValue\n    };\n  };\n}\n/**\n * This Observable creation function helps to accumulate an object of key & Observable of values to\n * an Observable of objects of key & value.\n * This comes in handy if you quickly want to create subsets as objects/state-slices of different Observables.\n *\n * The resulting Observable filters out undefined values forwards only distinct values and shared the aggregated output.\n *\n * @example\n *\n * Default usage:\n *\n * const object$: Observable<{\n *   prop1: number,\n *   prop2: string,\n *   prop3: string\n * }> = accumulateObservables({\n *   prop1: interval(42),\n *   prop2: of('lorem'),\n *   prop3: 'test'\n * });\n *\n * Usage with custom duration selector:\n *\n * const object$: Observable<{\n *   prop1: number,\n *   prop2: string,\n *   prop3: string\n * }> = accumulateObservables({\n *   prop1: interval(42),\n *   prop2: of('lorem'),\n *   prop3: 'test'\n * }, timer(0, 20));\n *\n * @param obj - An object of key & Observable values pairs\n * @param durationSelector - An Observable determining the duration for the internal coalescing method\n */\nfunction accumulateObservables(\n// @TODO type static or Observable to enable mixing of imperative and reatctive values\nobj, durationSelector = resolvedPromise$) {\n  const keys = Object.keys(obj);\n  // @TODO better typing to enable static values => coerceObservable(obj[key])\n  const observables = keys.map(key => obj[key].pipe(\n  // we avoid using the nullish operator later ;)\n  filter(v => v !== undefined),\n  // state \"changes\" differ from each other, this operator ensures distinct values\n  distinctUntilChanged()));\n  return combineLatest(observables).pipe(\n  // As combineLatest will emit multiple times for a change in multiple properties we coalesce those emissions\n  // together\n  coalesceWith(durationSelector),\n  // mapping array of values to object\n  map(values => values.reduce(getEntriesToObjectReducerFn(keys), {})),\n  // by using shareReplay we share the last composition work done to create the accumulated object\n  shareReplay({\n    refCount: true,\n    bufferSize: 1\n  }));\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { accumulateObservables, getZoneUnPatchedApi, timeoutSwitchMapWith };","map":{"version":3,"names":["ɵglobal","Observable","from","combineLatest","concatMap","mapTo","filter","distinctUntilChanged","map","shareReplay","coalesceWith","getZoneUnPatchedApi","targetOrName","name","timeout","delay","subscriber","asyncID","next","timeoutSwitchMapWith","o$","pipe","v","resolvedPromise","resolve","resolvedPromise$","getEntriesToObjectReducerFn","keys","accumulator","currentValue","currentIndex","accumulateObservables","obj","durationSelector","Object","observables","key","undefined","values","reduce","refCount","bufferSize"],"sources":["C:/Development/AngularComponent/ClientApp/node_modules/@rx-angular/cdk/fesm2020/cdk-internals-core.mjs"],"sourcesContent":["import { ɵglobal } from '@angular/core';\nimport { Observable, from, combineLatest } from 'rxjs';\nimport { concatMap, mapTo, filter, distinctUntilChanged, map, shareReplay } from 'rxjs/operators';\nimport { coalesceWith } from '@rx-angular/cdk/coalescing';\n\nfunction getZoneUnPatchedApi(targetOrName, name) {\n    // If the user has provided the API name as the first argument, for instance:\n    // `const addEventListener = getZoneUnPatchedApi('addEventListener');`\n    // Then we just swap arguments and make `global` or `window` as the default target.\n    if (typeof targetOrName === 'string') {\n        name = targetOrName;\n        targetOrName = ɵglobal;\n    }\n    return targetOrName['__zone_symbol__' + name] || targetOrName[name];\n}\n\n/**\n * Creates an Observable that emits after a setTimeout.\n * The timeout it unpatched to not avoid zone pollution\n * @param setTimeoutFn\n */\nfunction timeout(delay = 0) {\n    return new Observable((subscriber) => {\n        const asyncID = getZoneUnPatchedApi('setTimeout')(() => subscriber.next(0), delay);\n        return () => {\n            getZoneUnPatchedApi('clearTimeout')(asyncID);\n        };\n    });\n}\n/**\n *\n */\nfunction timeoutSwitchMapWith() {\n    return (o$) => o$.pipe(concatMap((v) => timeout().pipe(mapTo(v))));\n}\n\nconst resolvedPromise = getZoneUnPatchedApi('Promise').resolve();\nconst resolvedPromise$ = from(resolvedPromise);\n/**\n * @internal\n *\n * Used for typing\n */\nfunction getEntriesToObjectReducerFn(keys) {\n    return (accumulator, currentValue, currentIndex) => {\n        return {\n            ...accumulator,\n            [keys[currentIndex]]: currentValue,\n        };\n    };\n}\n/**\n * This Observable creation function helps to accumulate an object of key & Observable of values to\n * an Observable of objects of key & value.\n * This comes in handy if you quickly want to create subsets as objects/state-slices of different Observables.\n *\n * The resulting Observable filters out undefined values forwards only distinct values and shared the aggregated output.\n *\n * @example\n *\n * Default usage:\n *\n * const object$: Observable<{\n *   prop1: number,\n *   prop2: string,\n *   prop3: string\n * }> = accumulateObservables({\n *   prop1: interval(42),\n *   prop2: of('lorem'),\n *   prop3: 'test'\n * });\n *\n * Usage with custom duration selector:\n *\n * const object$: Observable<{\n *   prop1: number,\n *   prop2: string,\n *   prop3: string\n * }> = accumulateObservables({\n *   prop1: interval(42),\n *   prop2: of('lorem'),\n *   prop3: 'test'\n * }, timer(0, 20));\n *\n * @param obj - An object of key & Observable values pairs\n * @param durationSelector - An Observable determining the duration for the internal coalescing method\n */\nfunction accumulateObservables(\n// @TODO type static or Observable to enable mixing of imperative and reatctive values\nobj, durationSelector = resolvedPromise$) {\n    const keys = Object.keys(obj);\n    // @TODO better typing to enable static values => coerceObservable(obj[key])\n    const observables = keys.map((key) => obj[key].pipe(\n    // we avoid using the nullish operator later ;)\n    filter((v) => v !== undefined), \n    // state \"changes\" differ from each other, this operator ensures distinct values\n    distinctUntilChanged()));\n    return combineLatest(observables).pipe(\n    // As combineLatest will emit multiple times for a change in multiple properties we coalesce those emissions\n    // together\n    coalesceWith(durationSelector), \n    // mapping array of values to object\n    map((values) => values.reduce(getEntriesToObjectReducerFn(keys), {})), \n    // by using shareReplay we share the last composition work done to create the accumulated object\n    shareReplay({ refCount: true, bufferSize: 1 }));\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { accumulateObservables, getZoneUnPatchedApi, timeoutSwitchMapWith };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}